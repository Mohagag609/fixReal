
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model UnitPartner
 * 
 */
export type UnitPartner = $Result.DefaultSelection<Prisma.$UnitPartnerPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Installment
 * 
 */
export type Installment = $Result.DefaultSelection<Prisma.$InstallmentPayload>
/**
 * Model PartnerDebt
 * 
 */
export type PartnerDebt = $Result.DefaultSelection<Prisma.$PartnerDebtPayload>
/**
 * Model Safe
 * 
 */
export type Safe = $Result.DefaultSelection<Prisma.$SafePayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model Broker
 * 
 */
export type Broker = $Result.DefaultSelection<Prisma.$BrokerPayload>
/**
 * Model BrokerDue
 * 
 */
export type BrokerDue = $Result.DefaultSelection<Prisma.$BrokerDuePayload>
/**
 * Model PartnerGroup
 * 
 */
export type PartnerGroup = $Result.DefaultSelection<Prisma.$PartnerGroupPayload>
/**
 * Model PartnerGroupPartner
 * 
 */
export type PartnerGroupPartner = $Result.DefaultSelection<Prisma.$PartnerGroupPartnerPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model KeyVal
 * 
 */
export type KeyVal = $Result.DefaultSelection<Prisma.$KeyValPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitPartner`: Exposes CRUD operations for the **UnitPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitPartners
    * const unitPartners = await prisma.unitPartner.findMany()
    * ```
    */
  get unitPartner(): Prisma.UnitPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.installment`: Exposes CRUD operations for the **Installment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installments
    * const installments = await prisma.installment.findMany()
    * ```
    */
  get installment(): Prisma.InstallmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerDebt`: Exposes CRUD operations for the **PartnerDebt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerDebts
    * const partnerDebts = await prisma.partnerDebt.findMany()
    * ```
    */
  get partnerDebt(): Prisma.PartnerDebtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.safe`: Exposes CRUD operations for the **Safe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Safes
    * const safes = await prisma.safe.findMany()
    * ```
    */
  get safe(): Prisma.SafeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.broker`: Exposes CRUD operations for the **Broker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brokers
    * const brokers = await prisma.broker.findMany()
    * ```
    */
  get broker(): Prisma.BrokerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brokerDue`: Exposes CRUD operations for the **BrokerDue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BrokerDues
    * const brokerDues = await prisma.brokerDue.findMany()
    * ```
    */
  get brokerDue(): Prisma.BrokerDueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerGroup`: Exposes CRUD operations for the **PartnerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerGroups
    * const partnerGroups = await prisma.partnerGroup.findMany()
    * ```
    */
  get partnerGroup(): Prisma.PartnerGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerGroupPartner`: Exposes CRUD operations for the **PartnerGroupPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerGroupPartners
    * const partnerGroupPartners = await prisma.partnerGroupPartner.findMany()
    * ```
    */
  get partnerGroupPartner(): Prisma.PartnerGroupPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyVal`: Exposes CRUD operations for the **KeyVal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyVals
    * const keyVals = await prisma.keyVal.findMany()
    * ```
    */
  get keyVal(): Prisma.KeyValDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Unit: 'Unit',
    Partner: 'Partner',
    UnitPartner: 'UnitPartner',
    Contract: 'Contract',
    Installment: 'Installment',
    PartnerDebt: 'PartnerDebt',
    Safe: 'Safe',
    Transfer: 'Transfer',
    Voucher: 'Voucher',
    Broker: 'Broker',
    BrokerDue: 'BrokerDue',
    PartnerGroup: 'PartnerGroup',
    PartnerGroupPartner: 'PartnerGroupPartner',
    AuditLog: 'AuditLog',
    Settings: 'Settings',
    KeyVal: 'KeyVal',
    User: 'User',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "unit" | "partner" | "unitPartner" | "contract" | "installment" | "partnerDebt" | "safe" | "transfer" | "voucher" | "broker" | "brokerDue" | "partnerGroup" | "partnerGroupPartner" | "auditLog" | "settings" | "keyVal" | "user" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      UnitPartner: {
        payload: Prisma.$UnitPartnerPayload<ExtArgs>
        fields: Prisma.UnitPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          findFirst: {
            args: Prisma.UnitPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          findMany: {
            args: Prisma.UnitPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>[]
          }
          create: {
            args: Prisma.UnitPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          createMany: {
            args: Prisma.UnitPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>[]
          }
          delete: {
            args: Prisma.UnitPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          update: {
            args: Prisma.UnitPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          deleteMany: {
            args: Prisma.UnitPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>[]
          }
          upsert: {
            args: Prisma.UnitPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPartnerPayload>
          }
          aggregate: {
            args: Prisma.UnitPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitPartner>
          }
          groupBy: {
            args: Prisma.UnitPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<UnitPartnerCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Installment: {
        payload: Prisma.$InstallmentPayload<ExtArgs>
        fields: Prisma.InstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findFirst: {
            args: Prisma.InstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findMany: {
            args: Prisma.InstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          create: {
            args: Prisma.InstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          createMany: {
            args: Prisma.InstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          delete: {
            args: Prisma.InstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          update: {
            args: Prisma.InstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          deleteMany: {
            args: Prisma.InstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          upsert: {
            args: Prisma.InstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          aggregate: {
            args: Prisma.InstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallment>
          }
          groupBy: {
            args: Prisma.InstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstallmentCountAggregateOutputType> | number
          }
        }
      }
      PartnerDebt: {
        payload: Prisma.$PartnerDebtPayload<ExtArgs>
        fields: Prisma.PartnerDebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerDebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerDebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          findFirst: {
            args: Prisma.PartnerDebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerDebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          findMany: {
            args: Prisma.PartnerDebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>[]
          }
          create: {
            args: Prisma.PartnerDebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          createMany: {
            args: Prisma.PartnerDebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerDebtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>[]
          }
          delete: {
            args: Prisma.PartnerDebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          update: {
            args: Prisma.PartnerDebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerDebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerDebtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>[]
          }
          upsert: {
            args: Prisma.PartnerDebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDebtPayload>
          }
          aggregate: {
            args: Prisma.PartnerDebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerDebt>
          }
          groupBy: {
            args: Prisma.PartnerDebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerDebtGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerDebtCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerDebtCountAggregateOutputType> | number
          }
        }
      }
      Safe: {
        payload: Prisma.$SafePayload<ExtArgs>
        fields: Prisma.SafeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          findFirst: {
            args: Prisma.SafeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          findMany: {
            args: Prisma.SafeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>[]
          }
          create: {
            args: Prisma.SafeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          createMany: {
            args: Prisma.SafeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>[]
          }
          delete: {
            args: Prisma.SafeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          update: {
            args: Prisma.SafeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          deleteMany: {
            args: Prisma.SafeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SafeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>[]
          }
          upsert: {
            args: Prisma.SafeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafePayload>
          }
          aggregate: {
            args: Prisma.SafeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafe>
          }
          groupBy: {
            args: Prisma.SafeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafeCountArgs<ExtArgs>
            result: $Utils.Optional<SafeCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      Broker: {
        payload: Prisma.$BrokerPayload<ExtArgs>
        fields: Prisma.BrokerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrokerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrokerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          findFirst: {
            args: Prisma.BrokerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrokerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          findMany: {
            args: Prisma.BrokerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>[]
          }
          create: {
            args: Prisma.BrokerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          createMany: {
            args: Prisma.BrokerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrokerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>[]
          }
          delete: {
            args: Prisma.BrokerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          update: {
            args: Prisma.BrokerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          deleteMany: {
            args: Prisma.BrokerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrokerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrokerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>[]
          }
          upsert: {
            args: Prisma.BrokerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerPayload>
          }
          aggregate: {
            args: Prisma.BrokerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBroker>
          }
          groupBy: {
            args: Prisma.BrokerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrokerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrokerCountArgs<ExtArgs>
            result: $Utils.Optional<BrokerCountAggregateOutputType> | number
          }
        }
      }
      BrokerDue: {
        payload: Prisma.$BrokerDuePayload<ExtArgs>
        fields: Prisma.BrokerDueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrokerDueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrokerDueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          findFirst: {
            args: Prisma.BrokerDueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrokerDueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          findMany: {
            args: Prisma.BrokerDueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>[]
          }
          create: {
            args: Prisma.BrokerDueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          createMany: {
            args: Prisma.BrokerDueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrokerDueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>[]
          }
          delete: {
            args: Prisma.BrokerDueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          update: {
            args: Prisma.BrokerDueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          deleteMany: {
            args: Prisma.BrokerDueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrokerDueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrokerDueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>[]
          }
          upsert: {
            args: Prisma.BrokerDueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrokerDuePayload>
          }
          aggregate: {
            args: Prisma.BrokerDueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrokerDue>
          }
          groupBy: {
            args: Prisma.BrokerDueGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrokerDueGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrokerDueCountArgs<ExtArgs>
            result: $Utils.Optional<BrokerDueCountAggregateOutputType> | number
          }
        }
      }
      PartnerGroup: {
        payload: Prisma.$PartnerGroupPayload<ExtArgs>
        fields: Prisma.PartnerGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          findFirst: {
            args: Prisma.PartnerGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          findMany: {
            args: Prisma.PartnerGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>[]
          }
          create: {
            args: Prisma.PartnerGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          createMany: {
            args: Prisma.PartnerGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>[]
          }
          delete: {
            args: Prisma.PartnerGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          update: {
            args: Prisma.PartnerGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          deleteMany: {
            args: Prisma.PartnerGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>[]
          }
          upsert: {
            args: Prisma.PartnerGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
          }
          aggregate: {
            args: Prisma.PartnerGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerGroup>
          }
          groupBy: {
            args: Prisma.PartnerGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerGroupCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupCountAggregateOutputType> | number
          }
        }
      }
      PartnerGroupPartner: {
        payload: Prisma.$PartnerGroupPartnerPayload<ExtArgs>
        fields: Prisma.PartnerGroupPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerGroupPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerGroupPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerGroupPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerGroupPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerGroupPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerGroupPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerGroupPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerGroupPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerGroupPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          update: {
            args: Prisma.PartnerGroupPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerGroupPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerGroupPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerGroupPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>[]
          }
          upsert: {
            args: Prisma.PartnerGroupPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerGroupPartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerGroupPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerGroupPartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerGroupPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupPartnerCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      KeyVal: {
        payload: Prisma.$KeyValPayload<ExtArgs>
        fields: Prisma.KeyValFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyValFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyValFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          findFirst: {
            args: Prisma.KeyValFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyValFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          findMany: {
            args: Prisma.KeyValFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>[]
          }
          create: {
            args: Prisma.KeyValCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          createMany: {
            args: Prisma.KeyValCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeyValCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>[]
          }
          delete: {
            args: Prisma.KeyValDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          update: {
            args: Prisma.KeyValUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          deleteMany: {
            args: Prisma.KeyValDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyValUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeyValUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>[]
          }
          upsert: {
            args: Prisma.KeyValUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyValPayload>
          }
          aggregate: {
            args: Prisma.KeyValAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyVal>
          }
          groupBy: {
            args: Prisma.KeyValGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyValGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyValCountArgs<ExtArgs>
            result: $Utils.Optional<KeyValCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    unit?: UnitOmit
    partner?: PartnerOmit
    unitPartner?: UnitPartnerOmit
    contract?: ContractOmit
    installment?: InstallmentOmit
    partnerDebt?: PartnerDebtOmit
    safe?: SafeOmit
    transfer?: TransferOmit
    voucher?: VoucherOmit
    broker?: BrokerOmit
    brokerDue?: BrokerDueOmit
    partnerGroup?: PartnerGroupOmit
    partnerGroupPartner?: PartnerGroupPartnerOmit
    auditLog?: AuditLogOmit
    settings?: SettingsOmit
    keyVal?: KeyValOmit
    user?: UserOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    contracts: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | CustomerCountOutputTypeCountContractsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    contracts: number
    installments: number
    vouchers: number
    unitPartners: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | UnitCountOutputTypeCountContractsArgs
    installments?: boolean | UnitCountOutputTypeCountInstallmentsArgs
    vouchers?: boolean | UnitCountOutputTypeCountVouchersArgs
    unitPartners?: boolean | UnitCountOutputTypeCountUnitPartnersArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnitPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitPartnerWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    unitPartners: number
    partnerDebts: number
    partnerGroupPartners: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitPartners?: boolean | PartnerCountOutputTypeCountUnitPartnersArgs
    partnerDebts?: boolean | PartnerCountOutputTypeCountPartnerDebtsArgs
    partnerGroupPartners?: boolean | PartnerCountOutputTypeCountPartnerGroupPartnersArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountUnitPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitPartnerWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountPartnerDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerDebtWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountPartnerGroupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerGroupPartnerWhereInput
  }


  /**
   * Count Type SafeCountOutputType
   */

  export type SafeCountOutputType = {
    vouchers: number
    transfersFrom: number
    transfersTo: number
  }

  export type SafeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vouchers?: boolean | SafeCountOutputTypeCountVouchersArgs
    transfersFrom?: boolean | SafeCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | SafeCountOutputTypeCountTransfersToArgs
  }

  // Custom InputTypes
  /**
   * SafeCountOutputType without action
   */
  export type SafeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafeCountOutputType
     */
    select?: SafeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SafeCountOutputType without action
   */
  export type SafeCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * SafeCountOutputType without action
   */
  export type SafeCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * SafeCountOutputType without action
   */
  export type SafeCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type BrokerCountOutputType
   */

  export type BrokerCountOutputType = {
    brokerDues: number
  }

  export type BrokerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brokerDues?: boolean | BrokerCountOutputTypeCountBrokerDuesArgs
  }

  // Custom InputTypes
  /**
   * BrokerCountOutputType without action
   */
  export type BrokerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerCountOutputType
     */
    select?: BrokerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrokerCountOutputType without action
   */
  export type BrokerCountOutputTypeCountBrokerDuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrokerDueWhereInput
  }


  /**
   * Count Type PartnerGroupCountOutputType
   */

  export type PartnerGroupCountOutputType = {
    partners: number
  }

  export type PartnerGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partners?: boolean | PartnerGroupCountOutputTypeCountPartnersArgs
  }

  // Custom InputTypes
  /**
   * PartnerGroupCountOutputType without action
   */
  export type PartnerGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupCountOutputType
     */
    select?: PartnerGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerGroupCountOutputType without action
   */
  export type PartnerGroupCountOutputTypeCountPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerGroupPartnerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    nationalId: string | null
    address: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    nationalId: string | null
    address: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    nationalId: number
    address: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    nationalId?: true
    address?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    nationalId?: true
    address?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    nationalId?: true
    address?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    nationalId: string | null
    address: string | null
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    nationalId?: boolean
    address?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    contracts?: boolean | Customer$contractsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    nationalId?: boolean
    address?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    nationalId?: boolean
    address?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    nationalId?: boolean
    address?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "nationalId" | "address" | "status" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Customer$contractsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      nationalId: string | null
      address: string | null
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends Customer$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly nationalId: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly status: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.contracts
   */
  export type Customer$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type UnitSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    unitType: string | null
    area: string | null
    floor: string | null
    building: string | null
    totalPrice: number | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    unitType: string | null
    area: string | null
    floor: string | null
    building: string | null
    totalPrice: number | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    code: number
    name: number
    unitType: number
    area: number
    floor: number
    building: number
    totalPrice: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    totalPrice?: true
  }

  export type UnitSumAggregateInputType = {
    totalPrice?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unitType?: true
    area?: true
    floor?: true
    building?: true
    totalPrice?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unitType?: true
    area?: true
    floor?: true
    building?: true
    totalPrice?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unitType?: true
    area?: true
    floor?: true
    building?: true
    totalPrice?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    code: string
    name: string | null
    unitType: string
    area: string | null
    floor: string | null
    building: string | null
    totalPrice: number
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unitType?: boolean
    area?: boolean
    floor?: boolean
    building?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    contracts?: boolean | Unit$contractsArgs<ExtArgs>
    installments?: boolean | Unit$installmentsArgs<ExtArgs>
    vouchers?: boolean | Unit$vouchersArgs<ExtArgs>
    unitPartners?: boolean | Unit$unitPartnersArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unitType?: boolean
    area?: boolean
    floor?: boolean
    building?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unitType?: boolean
    area?: boolean
    floor?: boolean
    building?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    unitType?: boolean
    area?: boolean
    floor?: boolean
    building?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "unitType" | "area" | "floor" | "building" | "totalPrice" | "status" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Unit$contractsArgs<ExtArgs>
    installments?: boolean | Unit$installmentsArgs<ExtArgs>
    vouchers?: boolean | Unit$vouchersArgs<ExtArgs>
    unitPartners?: boolean | Unit$unitPartnersArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      installments: Prisma.$InstallmentPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      unitPartners: Prisma.$UnitPartnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string | null
      unitType: string
      area: string | null
      floor: string | null
      building: string | null
      totalPrice: number
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends Unit$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    installments<T extends Unit$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vouchers<T extends Unit$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitPartners<T extends Unit$unitPartnersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unitPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly code: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly unitType: FieldRef<"Unit", 'String'>
    readonly area: FieldRef<"Unit", 'String'>
    readonly floor: FieldRef<"Unit", 'String'>
    readonly building: FieldRef<"Unit", 'String'>
    readonly totalPrice: FieldRef<"Unit", 'Float'>
    readonly status: FieldRef<"Unit", 'String'>
    readonly notes: FieldRef<"Unit", 'String'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
    readonly deletedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.contracts
   */
  export type Unit$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Unit.installments
   */
  export type Unit$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Unit.vouchers
   */
  export type Unit$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Unit.unitPartners
   */
  export type Unit$unitPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    where?: UnitPartnerWhereInput
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    cursor?: UnitPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitPartnerScalarFieldEnum | UnitPartnerScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unitPartners?: boolean | Partner$unitPartnersArgs<ExtArgs>
    partnerDebts?: boolean | Partner$partnerDebtsArgs<ExtArgs>
    partnerGroupPartners?: boolean | Partner$partnerGroupPartnersArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitPartners?: boolean | Partner$unitPartnersArgs<ExtArgs>
    partnerDebts?: boolean | Partner$partnerDebtsArgs<ExtArgs>
    partnerGroupPartners?: boolean | Partner$partnerGroupPartnersArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      unitPartners: Prisma.$UnitPartnerPayload<ExtArgs>[]
      partnerDebts: Prisma.$PartnerDebtPayload<ExtArgs>[]
      partnerGroupPartners: Prisma.$PartnerGroupPartnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners and returns the data updated in the database.
     * @param {PartnerUpdateManyAndReturnArgs} args - Arguments to update many Partners.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitPartners<T extends Partner$unitPartnersArgs<ExtArgs> = {}>(args?: Subset<T, Partner$unitPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partnerDebts<T extends Partner$partnerDebtsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$partnerDebtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partnerGroupPartners<T extends Partner$partnerGroupPartnersArgs<ExtArgs> = {}>(args?: Subset<T, Partner$partnerGroupPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly phone: FieldRef<"Partner", 'String'>
    readonly notes: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
    readonly deletedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner updateManyAndReturn
   */
  export type PartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner.unitPartners
   */
  export type Partner$unitPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    where?: UnitPartnerWhereInput
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    cursor?: UnitPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitPartnerScalarFieldEnum | UnitPartnerScalarFieldEnum[]
  }

  /**
   * Partner.partnerDebts
   */
  export type Partner$partnerDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    where?: PartnerDebtWhereInput
    orderBy?: PartnerDebtOrderByWithRelationInput | PartnerDebtOrderByWithRelationInput[]
    cursor?: PartnerDebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerDebtScalarFieldEnum | PartnerDebtScalarFieldEnum[]
  }

  /**
   * Partner.partnerGroupPartners
   */
  export type Partner$partnerGroupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    where?: PartnerGroupPartnerWhereInput
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    cursor?: PartnerGroupPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerGroupPartnerScalarFieldEnum | PartnerGroupPartnerScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model UnitPartner
   */

  export type AggregateUnitPartner = {
    _count: UnitPartnerCountAggregateOutputType | null
    _avg: UnitPartnerAvgAggregateOutputType | null
    _sum: UnitPartnerSumAggregateOutputType | null
    _min: UnitPartnerMinAggregateOutputType | null
    _max: UnitPartnerMaxAggregateOutputType | null
  }

  export type UnitPartnerAvgAggregateOutputType = {
    percentage: number | null
  }

  export type UnitPartnerSumAggregateOutputType = {
    percentage: number | null
  }

  export type UnitPartnerMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    partnerId: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitPartnerMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    partnerId: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UnitPartnerCountAggregateOutputType = {
    id: number
    unitId: number
    partnerId: number
    percentage: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UnitPartnerAvgAggregateInputType = {
    percentage?: true
  }

  export type UnitPartnerSumAggregateInputType = {
    percentage?: true
  }

  export type UnitPartnerMinAggregateInputType = {
    id?: true
    unitId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitPartnerMaxAggregateInputType = {
    id?: true
    unitId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UnitPartnerCountAggregateInputType = {
    id?: true
    unitId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UnitPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitPartner to aggregate.
     */
    where?: UnitPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPartners to fetch.
     */
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitPartners
    **/
    _count?: true | UnitPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitPartnerMaxAggregateInputType
  }

  export type GetUnitPartnerAggregateType<T extends UnitPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitPartner[P]>
      : GetScalarType<T[P], AggregateUnitPartner[P]>
  }




  export type UnitPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitPartnerWhereInput
    orderBy?: UnitPartnerOrderByWithAggregationInput | UnitPartnerOrderByWithAggregationInput[]
    by: UnitPartnerScalarFieldEnum[] | UnitPartnerScalarFieldEnum
    having?: UnitPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitPartnerCountAggregateInputType | true
    _avg?: UnitPartnerAvgAggregateInputType
    _sum?: UnitPartnerSumAggregateInputType
    _min?: UnitPartnerMinAggregateInputType
    _max?: UnitPartnerMaxAggregateInputType
  }

  export type UnitPartnerGroupByOutputType = {
    id: string
    unitId: string
    partnerId: string
    percentage: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UnitPartnerCountAggregateOutputType | null
    _avg: UnitPartnerAvgAggregateOutputType | null
    _sum: UnitPartnerSumAggregateOutputType | null
    _min: UnitPartnerMinAggregateOutputType | null
    _max: UnitPartnerMaxAggregateOutputType | null
  }

  type GetUnitPartnerGroupByPayload<T extends UnitPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], UnitPartnerGroupByOutputType[P]>
        }
      >
    >


  export type UnitPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitPartner"]>

  export type UnitPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitPartner"]>

  export type UnitPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitPartner"]>

  export type UnitPartnerSelectScalar = {
    id?: boolean
    unitId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UnitPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "partnerId" | "percentage" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["unitPartner"]>
  export type UnitPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type UnitPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type UnitPartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $UnitPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitPartner"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      partnerId: string
      percentage: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["unitPartner"]>
    composites: {}
  }

  type UnitPartnerGetPayload<S extends boolean | null | undefined | UnitPartnerDefaultArgs> = $Result.GetResult<Prisma.$UnitPartnerPayload, S>

  type UnitPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitPartnerCountAggregateInputType | true
    }

  export interface UnitPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitPartner'], meta: { name: 'UnitPartner' } }
    /**
     * Find zero or one UnitPartner that matches the filter.
     * @param {UnitPartnerFindUniqueArgs} args - Arguments to find a UnitPartner
     * @example
     * // Get one UnitPartner
     * const unitPartner = await prisma.unitPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitPartnerFindUniqueArgs>(args: SelectSubset<T, UnitPartnerFindUniqueArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitPartnerFindUniqueOrThrowArgs} args - Arguments to find a UnitPartner
     * @example
     * // Get one UnitPartner
     * const unitPartner = await prisma.unitPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerFindFirstArgs} args - Arguments to find a UnitPartner
     * @example
     * // Get one UnitPartner
     * const unitPartner = await prisma.unitPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitPartnerFindFirstArgs>(args?: SelectSubset<T, UnitPartnerFindFirstArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerFindFirstOrThrowArgs} args - Arguments to find a UnitPartner
     * @example
     * // Get one UnitPartner
     * const unitPartner = await prisma.unitPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitPartners
     * const unitPartners = await prisma.unitPartner.findMany()
     * 
     * // Get first 10 UnitPartners
     * const unitPartners = await prisma.unitPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitPartnerWithIdOnly = await prisma.unitPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitPartnerFindManyArgs>(args?: SelectSubset<T, UnitPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitPartner.
     * @param {UnitPartnerCreateArgs} args - Arguments to create a UnitPartner.
     * @example
     * // Create one UnitPartner
     * const UnitPartner = await prisma.unitPartner.create({
     *   data: {
     *     // ... data to create a UnitPartner
     *   }
     * })
     * 
     */
    create<T extends UnitPartnerCreateArgs>(args: SelectSubset<T, UnitPartnerCreateArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitPartners.
     * @param {UnitPartnerCreateManyArgs} args - Arguments to create many UnitPartners.
     * @example
     * // Create many UnitPartners
     * const unitPartner = await prisma.unitPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitPartnerCreateManyArgs>(args?: SelectSubset<T, UnitPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitPartners and returns the data saved in the database.
     * @param {UnitPartnerCreateManyAndReturnArgs} args - Arguments to create many UnitPartners.
     * @example
     * // Create many UnitPartners
     * const unitPartner = await prisma.unitPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitPartners and only return the `id`
     * const unitPartnerWithIdOnly = await prisma.unitPartner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitPartner.
     * @param {UnitPartnerDeleteArgs} args - Arguments to delete one UnitPartner.
     * @example
     * // Delete one UnitPartner
     * const UnitPartner = await prisma.unitPartner.delete({
     *   where: {
     *     // ... filter to delete one UnitPartner
     *   }
     * })
     * 
     */
    delete<T extends UnitPartnerDeleteArgs>(args: SelectSubset<T, UnitPartnerDeleteArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitPartner.
     * @param {UnitPartnerUpdateArgs} args - Arguments to update one UnitPartner.
     * @example
     * // Update one UnitPartner
     * const unitPartner = await prisma.unitPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitPartnerUpdateArgs>(args: SelectSubset<T, UnitPartnerUpdateArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitPartners.
     * @param {UnitPartnerDeleteManyArgs} args - Arguments to filter UnitPartners to delete.
     * @example
     * // Delete a few UnitPartners
     * const { count } = await prisma.unitPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitPartnerDeleteManyArgs>(args?: SelectSubset<T, UnitPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitPartners
     * const unitPartner = await prisma.unitPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitPartnerUpdateManyArgs>(args: SelectSubset<T, UnitPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitPartners and returns the data updated in the database.
     * @param {UnitPartnerUpdateManyAndReturnArgs} args - Arguments to update many UnitPartners.
     * @example
     * // Update many UnitPartners
     * const unitPartner = await prisma.unitPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitPartners and only return the `id`
     * const unitPartnerWithIdOnly = await prisma.unitPartner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitPartner.
     * @param {UnitPartnerUpsertArgs} args - Arguments to update or create a UnitPartner.
     * @example
     * // Update or create a UnitPartner
     * const unitPartner = await prisma.unitPartner.upsert({
     *   create: {
     *     // ... data to create a UnitPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitPartner we want to update
     *   }
     * })
     */
    upsert<T extends UnitPartnerUpsertArgs>(args: SelectSubset<T, UnitPartnerUpsertArgs<ExtArgs>>): Prisma__UnitPartnerClient<$Result.GetResult<Prisma.$UnitPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerCountArgs} args - Arguments to filter UnitPartners to count.
     * @example
     * // Count the number of UnitPartners
     * const count = await prisma.unitPartner.count({
     *   where: {
     *     // ... the filter for the UnitPartners we want to count
     *   }
     * })
    **/
    count<T extends UnitPartnerCountArgs>(
      args?: Subset<T, UnitPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitPartnerAggregateArgs>(args: Subset<T, UnitPartnerAggregateArgs>): Prisma.PrismaPromise<GetUnitPartnerAggregateType<T>>

    /**
     * Group by UnitPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitPartnerGroupByArgs['orderBy'] }
        : { orderBy?: UnitPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitPartner model
   */
  readonly fields: UnitPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitPartner model
   */
  interface UnitPartnerFieldRefs {
    readonly id: FieldRef<"UnitPartner", 'String'>
    readonly unitId: FieldRef<"UnitPartner", 'String'>
    readonly partnerId: FieldRef<"UnitPartner", 'String'>
    readonly percentage: FieldRef<"UnitPartner", 'Float'>
    readonly createdAt: FieldRef<"UnitPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitPartner", 'DateTime'>
    readonly deletedAt: FieldRef<"UnitPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitPartner findUnique
   */
  export type UnitPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter, which UnitPartner to fetch.
     */
    where: UnitPartnerWhereUniqueInput
  }

  /**
   * UnitPartner findUniqueOrThrow
   */
  export type UnitPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter, which UnitPartner to fetch.
     */
    where: UnitPartnerWhereUniqueInput
  }

  /**
   * UnitPartner findFirst
   */
  export type UnitPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter, which UnitPartner to fetch.
     */
    where?: UnitPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPartners to fetch.
     */
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitPartners.
     */
    cursor?: UnitPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitPartners.
     */
    distinct?: UnitPartnerScalarFieldEnum | UnitPartnerScalarFieldEnum[]
  }

  /**
   * UnitPartner findFirstOrThrow
   */
  export type UnitPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter, which UnitPartner to fetch.
     */
    where?: UnitPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPartners to fetch.
     */
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitPartners.
     */
    cursor?: UnitPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitPartners.
     */
    distinct?: UnitPartnerScalarFieldEnum | UnitPartnerScalarFieldEnum[]
  }

  /**
   * UnitPartner findMany
   */
  export type UnitPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter, which UnitPartners to fetch.
     */
    where?: UnitPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitPartners to fetch.
     */
    orderBy?: UnitPartnerOrderByWithRelationInput | UnitPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitPartners.
     */
    cursor?: UnitPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitPartners.
     */
    skip?: number
    distinct?: UnitPartnerScalarFieldEnum | UnitPartnerScalarFieldEnum[]
  }

  /**
   * UnitPartner create
   */
  export type UnitPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitPartner.
     */
    data: XOR<UnitPartnerCreateInput, UnitPartnerUncheckedCreateInput>
  }

  /**
   * UnitPartner createMany
   */
  export type UnitPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitPartners.
     */
    data: UnitPartnerCreateManyInput | UnitPartnerCreateManyInput[]
  }

  /**
   * UnitPartner createManyAndReturn
   */
  export type UnitPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many UnitPartners.
     */
    data: UnitPartnerCreateManyInput | UnitPartnerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitPartner update
   */
  export type UnitPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitPartner.
     */
    data: XOR<UnitPartnerUpdateInput, UnitPartnerUncheckedUpdateInput>
    /**
     * Choose, which UnitPartner to update.
     */
    where: UnitPartnerWhereUniqueInput
  }

  /**
   * UnitPartner updateMany
   */
  export type UnitPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitPartners.
     */
    data: XOR<UnitPartnerUpdateManyMutationInput, UnitPartnerUncheckedUpdateManyInput>
    /**
     * Filter which UnitPartners to update
     */
    where?: UnitPartnerWhereInput
    /**
     * Limit how many UnitPartners to update.
     */
    limit?: number
  }

  /**
   * UnitPartner updateManyAndReturn
   */
  export type UnitPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * The data used to update UnitPartners.
     */
    data: XOR<UnitPartnerUpdateManyMutationInput, UnitPartnerUncheckedUpdateManyInput>
    /**
     * Filter which UnitPartners to update
     */
    where?: UnitPartnerWhereInput
    /**
     * Limit how many UnitPartners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitPartner upsert
   */
  export type UnitPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitPartner to update in case it exists.
     */
    where: UnitPartnerWhereUniqueInput
    /**
     * In case the UnitPartner found by the `where` argument doesn't exist, create a new UnitPartner with this data.
     */
    create: XOR<UnitPartnerCreateInput, UnitPartnerUncheckedCreateInput>
    /**
     * In case the UnitPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitPartnerUpdateInput, UnitPartnerUncheckedUpdateInput>
  }

  /**
   * UnitPartner delete
   */
  export type UnitPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
    /**
     * Filter which UnitPartner to delete.
     */
    where: UnitPartnerWhereUniqueInput
  }

  /**
   * UnitPartner deleteMany
   */
  export type UnitPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitPartners to delete
     */
    where?: UnitPartnerWhereInput
    /**
     * Limit how many UnitPartners to delete.
     */
    limit?: number
  }

  /**
   * UnitPartner without action
   */
  export type UnitPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitPartner
     */
    select?: UnitPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitPartner
     */
    omit?: UnitPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitPartnerInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    totalPrice: number | null
    discountAmount: number | null
    brokerPercent: number | null
    brokerAmount: number | null
    maintenanceDeposit: number | null
    installmentCount: number | null
    extraAnnual: number | null
    annualPaymentValue: number | null
    downPayment: number | null
  }

  export type ContractSumAggregateOutputType = {
    totalPrice: number | null
    discountAmount: number | null
    brokerPercent: number | null
    brokerAmount: number | null
    maintenanceDeposit: number | null
    installmentCount: number | null
    extraAnnual: number | null
    annualPaymentValue: number | null
    downPayment: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    customerId: string | null
    start: Date | null
    totalPrice: number | null
    discountAmount: number | null
    brokerName: string | null
    brokerPercent: number | null
    brokerAmount: number | null
    commissionSafeId: string | null
    downPaymentSafeId: string | null
    maintenanceDeposit: number | null
    installmentType: string | null
    installmentCount: number | null
    extraAnnual: number | null
    annualPaymentValue: number | null
    downPayment: number | null
    paymentType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    customerId: string | null
    start: Date | null
    totalPrice: number | null
    discountAmount: number | null
    brokerName: string | null
    brokerPercent: number | null
    brokerAmount: number | null
    commissionSafeId: string | null
    downPaymentSafeId: string | null
    maintenanceDeposit: number | null
    installmentType: string | null
    installmentCount: number | null
    extraAnnual: number | null
    annualPaymentValue: number | null
    downPayment: number | null
    paymentType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    unitId: number
    customerId: number
    start: number
    totalPrice: number
    discountAmount: number
    brokerName: number
    brokerPercent: number
    brokerAmount: number
    commissionSafeId: number
    downPaymentSafeId: number
    maintenanceDeposit: number
    installmentType: number
    installmentCount: number
    extraAnnual: number
    annualPaymentValue: number
    downPayment: number
    paymentType: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    totalPrice?: true
    discountAmount?: true
    brokerPercent?: true
    brokerAmount?: true
    maintenanceDeposit?: true
    installmentCount?: true
    extraAnnual?: true
    annualPaymentValue?: true
    downPayment?: true
  }

  export type ContractSumAggregateInputType = {
    totalPrice?: true
    discountAmount?: true
    brokerPercent?: true
    brokerAmount?: true
    maintenanceDeposit?: true
    installmentCount?: true
    extraAnnual?: true
    annualPaymentValue?: true
    downPayment?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    unitId?: true
    customerId?: true
    start?: true
    totalPrice?: true
    discountAmount?: true
    brokerName?: true
    brokerPercent?: true
    brokerAmount?: true
    commissionSafeId?: true
    downPaymentSafeId?: true
    maintenanceDeposit?: true
    installmentType?: true
    installmentCount?: true
    extraAnnual?: true
    annualPaymentValue?: true
    downPayment?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    unitId?: true
    customerId?: true
    start?: true
    totalPrice?: true
    discountAmount?: true
    brokerName?: true
    brokerPercent?: true
    brokerAmount?: true
    commissionSafeId?: true
    downPaymentSafeId?: true
    maintenanceDeposit?: true
    installmentType?: true
    installmentCount?: true
    extraAnnual?: true
    annualPaymentValue?: true
    downPayment?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    unitId?: true
    customerId?: true
    start?: true
    totalPrice?: true
    discountAmount?: true
    brokerName?: true
    brokerPercent?: true
    brokerAmount?: true
    commissionSafeId?: true
    downPaymentSafeId?: true
    maintenanceDeposit?: true
    installmentType?: true
    installmentCount?: true
    extraAnnual?: true
    annualPaymentValue?: true
    downPayment?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    unitId: string
    customerId: string
    start: Date
    totalPrice: number
    discountAmount: number
    brokerName: string | null
    brokerPercent: number
    brokerAmount: number
    commissionSafeId: string | null
    downPaymentSafeId: string | null
    maintenanceDeposit: number
    installmentType: string
    installmentCount: number
    extraAnnual: number
    annualPaymentValue: number
    downPayment: number
    paymentType: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    customerId?: boolean
    start?: boolean
    totalPrice?: boolean
    discountAmount?: boolean
    brokerName?: boolean
    brokerPercent?: boolean
    brokerAmount?: boolean
    commissionSafeId?: boolean
    downPaymentSafeId?: boolean
    maintenanceDeposit?: boolean
    installmentType?: boolean
    installmentCount?: boolean
    extraAnnual?: boolean
    annualPaymentValue?: boolean
    downPayment?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    customerId?: boolean
    start?: boolean
    totalPrice?: boolean
    discountAmount?: boolean
    brokerName?: boolean
    brokerPercent?: boolean
    brokerAmount?: boolean
    commissionSafeId?: boolean
    downPaymentSafeId?: boolean
    maintenanceDeposit?: boolean
    installmentType?: boolean
    installmentCount?: boolean
    extraAnnual?: boolean
    annualPaymentValue?: boolean
    downPayment?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    customerId?: boolean
    start?: boolean
    totalPrice?: boolean
    discountAmount?: boolean
    brokerName?: boolean
    brokerPercent?: boolean
    brokerAmount?: boolean
    commissionSafeId?: boolean
    downPaymentSafeId?: boolean
    maintenanceDeposit?: boolean
    installmentType?: boolean
    installmentCount?: boolean
    extraAnnual?: boolean
    annualPaymentValue?: boolean
    downPayment?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    unitId?: boolean
    customerId?: boolean
    start?: boolean
    totalPrice?: boolean
    discountAmount?: boolean
    brokerName?: boolean
    brokerPercent?: boolean
    brokerAmount?: boolean
    commissionSafeId?: boolean
    downPaymentSafeId?: boolean
    maintenanceDeposit?: boolean
    installmentType?: boolean
    installmentCount?: boolean
    extraAnnual?: boolean
    annualPaymentValue?: boolean
    downPayment?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "customerId" | "start" | "totalPrice" | "discountAmount" | "brokerName" | "brokerPercent" | "brokerAmount" | "commissionSafeId" | "downPaymentSafeId" | "maintenanceDeposit" | "installmentType" | "installmentCount" | "extraAnnual" | "annualPaymentValue" | "downPayment" | "paymentType" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      customerId: string
      start: Date
      totalPrice: number
      discountAmount: number
      brokerName: string | null
      brokerPercent: number
      brokerAmount: number
      commissionSafeId: string | null
      downPaymentSafeId: string | null
      maintenanceDeposit: number
      installmentType: string
      installmentCount: number
      extraAnnual: number
      annualPaymentValue: number
      downPayment: number
      paymentType: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly unitId: FieldRef<"Contract", 'String'>
    readonly customerId: FieldRef<"Contract", 'String'>
    readonly start: FieldRef<"Contract", 'DateTime'>
    readonly totalPrice: FieldRef<"Contract", 'Float'>
    readonly discountAmount: FieldRef<"Contract", 'Float'>
    readonly brokerName: FieldRef<"Contract", 'String'>
    readonly brokerPercent: FieldRef<"Contract", 'Float'>
    readonly brokerAmount: FieldRef<"Contract", 'Float'>
    readonly commissionSafeId: FieldRef<"Contract", 'String'>
    readonly downPaymentSafeId: FieldRef<"Contract", 'String'>
    readonly maintenanceDeposit: FieldRef<"Contract", 'Float'>
    readonly installmentType: FieldRef<"Contract", 'String'>
    readonly installmentCount: FieldRef<"Contract", 'Int'>
    readonly extraAnnual: FieldRef<"Contract", 'Int'>
    readonly annualPaymentValue: FieldRef<"Contract", 'Float'>
    readonly downPayment: FieldRef<"Contract", 'Float'>
    readonly paymentType: FieldRef<"Contract", 'String'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
    readonly deletedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Installment
   */

  export type AggregateInstallment = {
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  export type InstallmentAvgAggregateOutputType = {
    amount: number | null
  }

  export type InstallmentSumAggregateOutputType = {
    amount: number | null
  }

  export type InstallmentMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InstallmentMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InstallmentCountAggregateOutputType = {
    id: number
    unitId: number
    amount: number
    dueDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type InstallmentAvgAggregateInputType = {
    amount?: true
  }

  export type InstallmentSumAggregateInputType = {
    amount?: true
  }

  export type InstallmentMinAggregateInputType = {
    id?: true
    unitId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InstallmentMaxAggregateInputType = {
    id?: true
    unitId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InstallmentCountAggregateInputType = {
    id?: true
    unitId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type InstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installment to aggregate.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installments
    **/
    _count?: true | InstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentMaxAggregateInputType
  }

  export type GetInstallmentAggregateType<T extends InstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallment[P]>
      : GetScalarType<T[P], AggregateInstallment[P]>
  }




  export type InstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithAggregationInput | InstallmentOrderByWithAggregationInput[]
    by: InstallmentScalarFieldEnum[] | InstallmentScalarFieldEnum
    having?: InstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentCountAggregateInputType | true
    _avg?: InstallmentAvgAggregateInputType
    _sum?: InstallmentSumAggregateInputType
    _min?: InstallmentMinAggregateInputType
    _max?: InstallmentMaxAggregateInputType
  }

  export type InstallmentGroupByOutputType = {
    id: string
    unitId: string
    amount: number
    dueDate: Date
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  type GetInstallmentGroupByPayload<T extends InstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectScalar = {
    id?: boolean
    unitId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type InstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "amount" | "dueDate" | "status" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["installment"]>
  export type InstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type InstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type InstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $InstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Installment"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      amount: number
      dueDate: Date
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["installment"]>
    composites: {}
  }

  type InstallmentGetPayload<S extends boolean | null | undefined | InstallmentDefaultArgs> = $Result.GetResult<Prisma.$InstallmentPayload, S>

  type InstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstallmentCountAggregateInputType | true
    }

  export interface InstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Installment'], meta: { name: 'Installment' } }
    /**
     * Find zero or one Installment that matches the filter.
     * @param {InstallmentFindUniqueArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallmentFindUniqueArgs>(args: SelectSubset<T, InstallmentFindUniqueArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Installment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstallmentFindUniqueOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Installment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallmentFindFirstArgs>(args?: SelectSubset<T, InstallmentFindFirstArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Installment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installments
     * const installments = await prisma.installment.findMany()
     * 
     * // Get first 10 Installments
     * const installments = await prisma.installment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentWithIdOnly = await prisma.installment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallmentFindManyArgs>(args?: SelectSubset<T, InstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Installment.
     * @param {InstallmentCreateArgs} args - Arguments to create a Installment.
     * @example
     * // Create one Installment
     * const Installment = await prisma.installment.create({
     *   data: {
     *     // ... data to create a Installment
     *   }
     * })
     * 
     */
    create<T extends InstallmentCreateArgs>(args: SelectSubset<T, InstallmentCreateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Installments.
     * @param {InstallmentCreateManyArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallmentCreateManyArgs>(args?: SelectSubset<T, InstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Installments and returns the data saved in the database.
     * @param {InstallmentCreateManyAndReturnArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Installment.
     * @param {InstallmentDeleteArgs} args - Arguments to delete one Installment.
     * @example
     * // Delete one Installment
     * const Installment = await prisma.installment.delete({
     *   where: {
     *     // ... filter to delete one Installment
     *   }
     * })
     * 
     */
    delete<T extends InstallmentDeleteArgs>(args: SelectSubset<T, InstallmentDeleteArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Installment.
     * @param {InstallmentUpdateArgs} args - Arguments to update one Installment.
     * @example
     * // Update one Installment
     * const installment = await prisma.installment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallmentUpdateArgs>(args: SelectSubset<T, InstallmentUpdateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Installments.
     * @param {InstallmentDeleteManyArgs} args - Arguments to filter Installments to delete.
     * @example
     * // Delete a few Installments
     * const { count } = await prisma.installment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallmentDeleteManyArgs>(args?: SelectSubset<T, InstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallmentUpdateManyArgs>(args: SelectSubset<T, InstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments and returns the data updated in the database.
     * @param {InstallmentUpdateManyAndReturnArgs} args - Arguments to update many Installments.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Installment.
     * @param {InstallmentUpsertArgs} args - Arguments to update or create a Installment.
     * @example
     * // Update or create a Installment
     * const installment = await prisma.installment.upsert({
     *   create: {
     *     // ... data to create a Installment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installment we want to update
     *   }
     * })
     */
    upsert<T extends InstallmentUpsertArgs>(args: SelectSubset<T, InstallmentUpsertArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentCountArgs} args - Arguments to filter Installments to count.
     * @example
     * // Count the number of Installments
     * const count = await prisma.installment.count({
     *   where: {
     *     // ... the filter for the Installments we want to count
     *   }
     * })
    **/
    count<T extends InstallmentCountArgs>(
      args?: Subset<T, InstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentAggregateArgs>(args: Subset<T, InstallmentAggregateArgs>): Prisma.PrismaPromise<GetInstallmentAggregateType<T>>

    /**
     * Group by Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Installment model
   */
  readonly fields: InstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Installment model
   */
  interface InstallmentFieldRefs {
    readonly id: FieldRef<"Installment", 'String'>
    readonly unitId: FieldRef<"Installment", 'String'>
    readonly amount: FieldRef<"Installment", 'Float'>
    readonly dueDate: FieldRef<"Installment", 'DateTime'>
    readonly status: FieldRef<"Installment", 'String'>
    readonly notes: FieldRef<"Installment", 'String'>
    readonly createdAt: FieldRef<"Installment", 'DateTime'>
    readonly updatedAt: FieldRef<"Installment", 'DateTime'>
    readonly deletedAt: FieldRef<"Installment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Installment findUnique
   */
  export type InstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findUniqueOrThrow
   */
  export type InstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findFirst
   */
  export type InstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findFirstOrThrow
   */
  export type InstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findMany
   */
  export type InstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installments to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment create
   */
  export type InstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Installment.
     */
    data: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
  }

  /**
   * Installment createMany
   */
  export type InstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
  }

  /**
   * Installment createManyAndReturn
   */
  export type InstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment update
   */
  export type InstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Installment.
     */
    data: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
    /**
     * Choose, which Installment to update.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment updateMany
   */
  export type InstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to update.
     */
    limit?: number
  }

  /**
   * Installment updateManyAndReturn
   */
  export type InstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment upsert
   */
  export type InstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Installment to update in case it exists.
     */
    where: InstallmentWhereUniqueInput
    /**
     * In case the Installment found by the `where` argument doesn't exist, create a new Installment with this data.
     */
    create: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
    /**
     * In case the Installment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
  }

  /**
   * Installment delete
   */
  export type InstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter which Installment to delete.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment deleteMany
   */
  export type InstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installments to delete
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to delete.
     */
    limit?: number
  }

  /**
   * Installment without action
   */
  export type InstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
  }


  /**
   * Model PartnerDebt
   */

  export type AggregatePartnerDebt = {
    _count: PartnerDebtCountAggregateOutputType | null
    _avg: PartnerDebtAvgAggregateOutputType | null
    _sum: PartnerDebtSumAggregateOutputType | null
    _min: PartnerDebtMinAggregateOutputType | null
    _max: PartnerDebtMaxAggregateOutputType | null
  }

  export type PartnerDebtAvgAggregateOutputType = {
    amount: number | null
  }

  export type PartnerDebtSumAggregateOutputType = {
    amount: number | null
  }

  export type PartnerDebtMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerDebtMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerDebtCountAggregateOutputType = {
    id: number
    partnerId: number
    amount: number
    dueDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PartnerDebtAvgAggregateInputType = {
    amount?: true
  }

  export type PartnerDebtSumAggregateInputType = {
    amount?: true
  }

  export type PartnerDebtMinAggregateInputType = {
    id?: true
    partnerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerDebtMaxAggregateInputType = {
    id?: true
    partnerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerDebtCountAggregateInputType = {
    id?: true
    partnerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PartnerDebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerDebt to aggregate.
     */
    where?: PartnerDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDebts to fetch.
     */
    orderBy?: PartnerDebtOrderByWithRelationInput | PartnerDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerDebts
    **/
    _count?: true | PartnerDebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerDebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerDebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerDebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerDebtMaxAggregateInputType
  }

  export type GetPartnerDebtAggregateType<T extends PartnerDebtAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerDebt[P]>
      : GetScalarType<T[P], AggregatePartnerDebt[P]>
  }




  export type PartnerDebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerDebtWhereInput
    orderBy?: PartnerDebtOrderByWithAggregationInput | PartnerDebtOrderByWithAggregationInput[]
    by: PartnerDebtScalarFieldEnum[] | PartnerDebtScalarFieldEnum
    having?: PartnerDebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerDebtCountAggregateInputType | true
    _avg?: PartnerDebtAvgAggregateInputType
    _sum?: PartnerDebtSumAggregateInputType
    _min?: PartnerDebtMinAggregateInputType
    _max?: PartnerDebtMaxAggregateInputType
  }

  export type PartnerDebtGroupByOutputType = {
    id: string
    partnerId: string
    amount: number
    dueDate: Date
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PartnerDebtCountAggregateOutputType | null
    _avg: PartnerDebtAvgAggregateOutputType | null
    _sum: PartnerDebtSumAggregateOutputType | null
    _min: PartnerDebtMinAggregateOutputType | null
    _max: PartnerDebtMaxAggregateOutputType | null
  }

  type GetPartnerDebtGroupByPayload<T extends PartnerDebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerDebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerDebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerDebtGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerDebtGroupByOutputType[P]>
        }
      >
    >


  export type PartnerDebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDebt"]>

  export type PartnerDebtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDebt"]>

  export type PartnerDebtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDebt"]>

  export type PartnerDebtSelectScalar = {
    id?: boolean
    partnerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PartnerDebtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerId" | "amount" | "dueDate" | "status" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["partnerDebt"]>
  export type PartnerDebtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerDebtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerDebtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerDebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerDebt"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      amount: number
      dueDate: Date
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["partnerDebt"]>
    composites: {}
  }

  type PartnerDebtGetPayload<S extends boolean | null | undefined | PartnerDebtDefaultArgs> = $Result.GetResult<Prisma.$PartnerDebtPayload, S>

  type PartnerDebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerDebtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerDebtCountAggregateInputType | true
    }

  export interface PartnerDebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerDebt'], meta: { name: 'PartnerDebt' } }
    /**
     * Find zero or one PartnerDebt that matches the filter.
     * @param {PartnerDebtFindUniqueArgs} args - Arguments to find a PartnerDebt
     * @example
     * // Get one PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerDebtFindUniqueArgs>(args: SelectSubset<T, PartnerDebtFindUniqueArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerDebt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerDebtFindUniqueOrThrowArgs} args - Arguments to find a PartnerDebt
     * @example
     * // Get one PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerDebtFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerDebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerDebt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtFindFirstArgs} args - Arguments to find a PartnerDebt
     * @example
     * // Get one PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerDebtFindFirstArgs>(args?: SelectSubset<T, PartnerDebtFindFirstArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerDebt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtFindFirstOrThrowArgs} args - Arguments to find a PartnerDebt
     * @example
     * // Get one PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerDebtFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerDebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerDebts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerDebts
     * const partnerDebts = await prisma.partnerDebt.findMany()
     * 
     * // Get first 10 PartnerDebts
     * const partnerDebts = await prisma.partnerDebt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerDebtWithIdOnly = await prisma.partnerDebt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerDebtFindManyArgs>(args?: SelectSubset<T, PartnerDebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerDebt.
     * @param {PartnerDebtCreateArgs} args - Arguments to create a PartnerDebt.
     * @example
     * // Create one PartnerDebt
     * const PartnerDebt = await prisma.partnerDebt.create({
     *   data: {
     *     // ... data to create a PartnerDebt
     *   }
     * })
     * 
     */
    create<T extends PartnerDebtCreateArgs>(args: SelectSubset<T, PartnerDebtCreateArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerDebts.
     * @param {PartnerDebtCreateManyArgs} args - Arguments to create many PartnerDebts.
     * @example
     * // Create many PartnerDebts
     * const partnerDebt = await prisma.partnerDebt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerDebtCreateManyArgs>(args?: SelectSubset<T, PartnerDebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerDebts and returns the data saved in the database.
     * @param {PartnerDebtCreateManyAndReturnArgs} args - Arguments to create many PartnerDebts.
     * @example
     * // Create many PartnerDebts
     * const partnerDebt = await prisma.partnerDebt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerDebts and only return the `id`
     * const partnerDebtWithIdOnly = await prisma.partnerDebt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerDebtCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerDebtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerDebt.
     * @param {PartnerDebtDeleteArgs} args - Arguments to delete one PartnerDebt.
     * @example
     * // Delete one PartnerDebt
     * const PartnerDebt = await prisma.partnerDebt.delete({
     *   where: {
     *     // ... filter to delete one PartnerDebt
     *   }
     * })
     * 
     */
    delete<T extends PartnerDebtDeleteArgs>(args: SelectSubset<T, PartnerDebtDeleteArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerDebt.
     * @param {PartnerDebtUpdateArgs} args - Arguments to update one PartnerDebt.
     * @example
     * // Update one PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerDebtUpdateArgs>(args: SelectSubset<T, PartnerDebtUpdateArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerDebts.
     * @param {PartnerDebtDeleteManyArgs} args - Arguments to filter PartnerDebts to delete.
     * @example
     * // Delete a few PartnerDebts
     * const { count } = await prisma.partnerDebt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDebtDeleteManyArgs>(args?: SelectSubset<T, PartnerDebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerDebts
     * const partnerDebt = await prisma.partnerDebt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerDebtUpdateManyArgs>(args: SelectSubset<T, PartnerDebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerDebts and returns the data updated in the database.
     * @param {PartnerDebtUpdateManyAndReturnArgs} args - Arguments to update many PartnerDebts.
     * @example
     * // Update many PartnerDebts
     * const partnerDebt = await prisma.partnerDebt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerDebts and only return the `id`
     * const partnerDebtWithIdOnly = await prisma.partnerDebt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerDebtUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerDebtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerDebt.
     * @param {PartnerDebtUpsertArgs} args - Arguments to update or create a PartnerDebt.
     * @example
     * // Update or create a PartnerDebt
     * const partnerDebt = await prisma.partnerDebt.upsert({
     *   create: {
     *     // ... data to create a PartnerDebt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerDebt we want to update
     *   }
     * })
     */
    upsert<T extends PartnerDebtUpsertArgs>(args: SelectSubset<T, PartnerDebtUpsertArgs<ExtArgs>>): Prisma__PartnerDebtClient<$Result.GetResult<Prisma.$PartnerDebtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerDebts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtCountArgs} args - Arguments to filter PartnerDebts to count.
     * @example
     * // Count the number of PartnerDebts
     * const count = await prisma.partnerDebt.count({
     *   where: {
     *     // ... the filter for the PartnerDebts we want to count
     *   }
     * })
    **/
    count<T extends PartnerDebtCountArgs>(
      args?: Subset<T, PartnerDebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerDebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerDebtAggregateArgs>(args: Subset<T, PartnerDebtAggregateArgs>): Prisma.PrismaPromise<GetPartnerDebtAggregateType<T>>

    /**
     * Group by PartnerDebt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerDebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerDebtGroupByArgs['orderBy'] }
        : { orderBy?: PartnerDebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerDebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerDebt model
   */
  readonly fields: PartnerDebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerDebt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerDebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerDebt model
   */
  interface PartnerDebtFieldRefs {
    readonly id: FieldRef<"PartnerDebt", 'String'>
    readonly partnerId: FieldRef<"PartnerDebt", 'String'>
    readonly amount: FieldRef<"PartnerDebt", 'Float'>
    readonly dueDate: FieldRef<"PartnerDebt", 'DateTime'>
    readonly status: FieldRef<"PartnerDebt", 'String'>
    readonly notes: FieldRef<"PartnerDebt", 'String'>
    readonly createdAt: FieldRef<"PartnerDebt", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerDebt", 'DateTime'>
    readonly deletedAt: FieldRef<"PartnerDebt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerDebt findUnique
   */
  export type PartnerDebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDebt to fetch.
     */
    where: PartnerDebtWhereUniqueInput
  }

  /**
   * PartnerDebt findUniqueOrThrow
   */
  export type PartnerDebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDebt to fetch.
     */
    where: PartnerDebtWhereUniqueInput
  }

  /**
   * PartnerDebt findFirst
   */
  export type PartnerDebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDebt to fetch.
     */
    where?: PartnerDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDebts to fetch.
     */
    orderBy?: PartnerDebtOrderByWithRelationInput | PartnerDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerDebts.
     */
    cursor?: PartnerDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerDebts.
     */
    distinct?: PartnerDebtScalarFieldEnum | PartnerDebtScalarFieldEnum[]
  }

  /**
   * PartnerDebt findFirstOrThrow
   */
  export type PartnerDebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDebt to fetch.
     */
    where?: PartnerDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDebts to fetch.
     */
    orderBy?: PartnerDebtOrderByWithRelationInput | PartnerDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerDebts.
     */
    cursor?: PartnerDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDebts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerDebts.
     */
    distinct?: PartnerDebtScalarFieldEnum | PartnerDebtScalarFieldEnum[]
  }

  /**
   * PartnerDebt findMany
   */
  export type PartnerDebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDebts to fetch.
     */
    where?: PartnerDebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDebts to fetch.
     */
    orderBy?: PartnerDebtOrderByWithRelationInput | PartnerDebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerDebts.
     */
    cursor?: PartnerDebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDebts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDebts.
     */
    skip?: number
    distinct?: PartnerDebtScalarFieldEnum | PartnerDebtScalarFieldEnum[]
  }

  /**
   * PartnerDebt create
   */
  export type PartnerDebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerDebt.
     */
    data: XOR<PartnerDebtCreateInput, PartnerDebtUncheckedCreateInput>
  }

  /**
   * PartnerDebt createMany
   */
  export type PartnerDebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerDebts.
     */
    data: PartnerDebtCreateManyInput | PartnerDebtCreateManyInput[]
  }

  /**
   * PartnerDebt createManyAndReturn
   */
  export type PartnerDebtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerDebts.
     */
    data: PartnerDebtCreateManyInput | PartnerDebtCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerDebt update
   */
  export type PartnerDebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerDebt.
     */
    data: XOR<PartnerDebtUpdateInput, PartnerDebtUncheckedUpdateInput>
    /**
     * Choose, which PartnerDebt to update.
     */
    where: PartnerDebtWhereUniqueInput
  }

  /**
   * PartnerDebt updateMany
   */
  export type PartnerDebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerDebts.
     */
    data: XOR<PartnerDebtUpdateManyMutationInput, PartnerDebtUncheckedUpdateManyInput>
    /**
     * Filter which PartnerDebts to update
     */
    where?: PartnerDebtWhereInput
    /**
     * Limit how many PartnerDebts to update.
     */
    limit?: number
  }

  /**
   * PartnerDebt updateManyAndReturn
   */
  export type PartnerDebtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * The data used to update PartnerDebts.
     */
    data: XOR<PartnerDebtUpdateManyMutationInput, PartnerDebtUncheckedUpdateManyInput>
    /**
     * Filter which PartnerDebts to update
     */
    where?: PartnerDebtWhereInput
    /**
     * Limit how many PartnerDebts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerDebt upsert
   */
  export type PartnerDebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerDebt to update in case it exists.
     */
    where: PartnerDebtWhereUniqueInput
    /**
     * In case the PartnerDebt found by the `where` argument doesn't exist, create a new PartnerDebt with this data.
     */
    create: XOR<PartnerDebtCreateInput, PartnerDebtUncheckedCreateInput>
    /**
     * In case the PartnerDebt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerDebtUpdateInput, PartnerDebtUncheckedUpdateInput>
  }

  /**
   * PartnerDebt delete
   */
  export type PartnerDebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
    /**
     * Filter which PartnerDebt to delete.
     */
    where: PartnerDebtWhereUniqueInput
  }

  /**
   * PartnerDebt deleteMany
   */
  export type PartnerDebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerDebts to delete
     */
    where?: PartnerDebtWhereInput
    /**
     * Limit how many PartnerDebts to delete.
     */
    limit?: number
  }

  /**
   * PartnerDebt without action
   */
  export type PartnerDebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDebt
     */
    select?: PartnerDebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDebt
     */
    omit?: PartnerDebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDebtInclude<ExtArgs> | null
  }


  /**
   * Model Safe
   */

  export type AggregateSafe = {
    _count: SafeCountAggregateOutputType | null
    _avg: SafeAvgAggregateOutputType | null
    _sum: SafeSumAggregateOutputType | null
    _min: SafeMinAggregateOutputType | null
    _max: SafeMaxAggregateOutputType | null
  }

  export type SafeAvgAggregateOutputType = {
    balance: number | null
  }

  export type SafeSumAggregateOutputType = {
    balance: number | null
  }

  export type SafeMinAggregateOutputType = {
    id: string | null
    name: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SafeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SafeCountAggregateOutputType = {
    id: number
    name: number
    balance: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SafeAvgAggregateInputType = {
    balance?: true
  }

  export type SafeSumAggregateInputType = {
    balance?: true
  }

  export type SafeMinAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SafeMaxAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SafeCountAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SafeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Safe to aggregate.
     */
    where?: SafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Safes to fetch.
     */
    orderBy?: SafeOrderByWithRelationInput | SafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Safes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Safes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Safes
    **/
    _count?: true | SafeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SafeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SafeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafeMaxAggregateInputType
  }

  export type GetSafeAggregateType<T extends SafeAggregateArgs> = {
        [P in keyof T & keyof AggregateSafe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafe[P]>
      : GetScalarType<T[P], AggregateSafe[P]>
  }




  export type SafeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafeWhereInput
    orderBy?: SafeOrderByWithAggregationInput | SafeOrderByWithAggregationInput[]
    by: SafeScalarFieldEnum[] | SafeScalarFieldEnum
    having?: SafeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafeCountAggregateInputType | true
    _avg?: SafeAvgAggregateInputType
    _sum?: SafeSumAggregateInputType
    _min?: SafeMinAggregateInputType
    _max?: SafeMaxAggregateInputType
  }

  export type SafeGroupByOutputType = {
    id: string
    name: string
    balance: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SafeCountAggregateOutputType | null
    _avg: SafeAvgAggregateOutputType | null
    _sum: SafeSumAggregateOutputType | null
    _min: SafeMinAggregateOutputType | null
    _max: SafeMaxAggregateOutputType | null
  }

  type GetSafeGroupByPayload<T extends SafeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafeGroupByOutputType[P]>
            : GetScalarType<T[P], SafeGroupByOutputType[P]>
        }
      >
    >


  export type SafeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    vouchers?: boolean | Safe$vouchersArgs<ExtArgs>
    transfersFrom?: boolean | Safe$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Safe$transfersToArgs<ExtArgs>
    _count?: boolean | SafeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safe"]>

  export type SafeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["safe"]>

  export type SafeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["safe"]>

  export type SafeSelectScalar = {
    id?: boolean
    name?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SafeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "balance" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["safe"]>
  export type SafeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vouchers?: boolean | Safe$vouchersArgs<ExtArgs>
    transfersFrom?: boolean | Safe$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Safe$transfersToArgs<ExtArgs>
    _count?: boolean | SafeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SafeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SafeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SafePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Safe"
    objects: {
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      transfersFrom: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      balance: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["safe"]>
    composites: {}
  }

  type SafeGetPayload<S extends boolean | null | undefined | SafeDefaultArgs> = $Result.GetResult<Prisma.$SafePayload, S>

  type SafeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SafeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SafeCountAggregateInputType | true
    }

  export interface SafeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Safe'], meta: { name: 'Safe' } }
    /**
     * Find zero or one Safe that matches the filter.
     * @param {SafeFindUniqueArgs} args - Arguments to find a Safe
     * @example
     * // Get one Safe
     * const safe = await prisma.safe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafeFindUniqueArgs>(args: SelectSubset<T, SafeFindUniqueArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Safe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SafeFindUniqueOrThrowArgs} args - Arguments to find a Safe
     * @example
     * // Get one Safe
     * const safe = await prisma.safe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafeFindUniqueOrThrowArgs>(args: SelectSubset<T, SafeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Safe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeFindFirstArgs} args - Arguments to find a Safe
     * @example
     * // Get one Safe
     * const safe = await prisma.safe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafeFindFirstArgs>(args?: SelectSubset<T, SafeFindFirstArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Safe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeFindFirstOrThrowArgs} args - Arguments to find a Safe
     * @example
     * // Get one Safe
     * const safe = await prisma.safe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafeFindFirstOrThrowArgs>(args?: SelectSubset<T, SafeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Safes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Safes
     * const safes = await prisma.safe.findMany()
     * 
     * // Get first 10 Safes
     * const safes = await prisma.safe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safeWithIdOnly = await prisma.safe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafeFindManyArgs>(args?: SelectSubset<T, SafeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Safe.
     * @param {SafeCreateArgs} args - Arguments to create a Safe.
     * @example
     * // Create one Safe
     * const Safe = await prisma.safe.create({
     *   data: {
     *     // ... data to create a Safe
     *   }
     * })
     * 
     */
    create<T extends SafeCreateArgs>(args: SelectSubset<T, SafeCreateArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Safes.
     * @param {SafeCreateManyArgs} args - Arguments to create many Safes.
     * @example
     * // Create many Safes
     * const safe = await prisma.safe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafeCreateManyArgs>(args?: SelectSubset<T, SafeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Safes and returns the data saved in the database.
     * @param {SafeCreateManyAndReturnArgs} args - Arguments to create many Safes.
     * @example
     * // Create many Safes
     * const safe = await prisma.safe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Safes and only return the `id`
     * const safeWithIdOnly = await prisma.safe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafeCreateManyAndReturnArgs>(args?: SelectSubset<T, SafeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Safe.
     * @param {SafeDeleteArgs} args - Arguments to delete one Safe.
     * @example
     * // Delete one Safe
     * const Safe = await prisma.safe.delete({
     *   where: {
     *     // ... filter to delete one Safe
     *   }
     * })
     * 
     */
    delete<T extends SafeDeleteArgs>(args: SelectSubset<T, SafeDeleteArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Safe.
     * @param {SafeUpdateArgs} args - Arguments to update one Safe.
     * @example
     * // Update one Safe
     * const safe = await prisma.safe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafeUpdateArgs>(args: SelectSubset<T, SafeUpdateArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Safes.
     * @param {SafeDeleteManyArgs} args - Arguments to filter Safes to delete.
     * @example
     * // Delete a few Safes
     * const { count } = await prisma.safe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafeDeleteManyArgs>(args?: SelectSubset<T, SafeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Safes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Safes
     * const safe = await prisma.safe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafeUpdateManyArgs>(args: SelectSubset<T, SafeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Safes and returns the data updated in the database.
     * @param {SafeUpdateManyAndReturnArgs} args - Arguments to update many Safes.
     * @example
     * // Update many Safes
     * const safe = await prisma.safe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Safes and only return the `id`
     * const safeWithIdOnly = await prisma.safe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SafeUpdateManyAndReturnArgs>(args: SelectSubset<T, SafeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Safe.
     * @param {SafeUpsertArgs} args - Arguments to update or create a Safe.
     * @example
     * // Update or create a Safe
     * const safe = await prisma.safe.upsert({
     *   create: {
     *     // ... data to create a Safe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Safe we want to update
     *   }
     * })
     */
    upsert<T extends SafeUpsertArgs>(args: SelectSubset<T, SafeUpsertArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Safes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeCountArgs} args - Arguments to filter Safes to count.
     * @example
     * // Count the number of Safes
     * const count = await prisma.safe.count({
     *   where: {
     *     // ... the filter for the Safes we want to count
     *   }
     * })
    **/
    count<T extends SafeCountArgs>(
      args?: Subset<T, SafeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Safe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafeAggregateArgs>(args: Subset<T, SafeAggregateArgs>): Prisma.PrismaPromise<GetSafeAggregateType<T>>

    /**
     * Group by Safe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafeGroupByArgs['orderBy'] }
        : { orderBy?: SafeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Safe model
   */
  readonly fields: SafeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Safe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vouchers<T extends Safe$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Safe$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends Safe$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Safe$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Safe$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Safe$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Safe model
   */
  interface SafeFieldRefs {
    readonly id: FieldRef<"Safe", 'String'>
    readonly name: FieldRef<"Safe", 'String'>
    readonly balance: FieldRef<"Safe", 'Float'>
    readonly createdAt: FieldRef<"Safe", 'DateTime'>
    readonly updatedAt: FieldRef<"Safe", 'DateTime'>
    readonly deletedAt: FieldRef<"Safe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Safe findUnique
   */
  export type SafeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter, which Safe to fetch.
     */
    where: SafeWhereUniqueInput
  }

  /**
   * Safe findUniqueOrThrow
   */
  export type SafeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter, which Safe to fetch.
     */
    where: SafeWhereUniqueInput
  }

  /**
   * Safe findFirst
   */
  export type SafeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter, which Safe to fetch.
     */
    where?: SafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Safes to fetch.
     */
    orderBy?: SafeOrderByWithRelationInput | SafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Safes.
     */
    cursor?: SafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Safes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Safes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Safes.
     */
    distinct?: SafeScalarFieldEnum | SafeScalarFieldEnum[]
  }

  /**
   * Safe findFirstOrThrow
   */
  export type SafeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter, which Safe to fetch.
     */
    where?: SafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Safes to fetch.
     */
    orderBy?: SafeOrderByWithRelationInput | SafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Safes.
     */
    cursor?: SafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Safes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Safes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Safes.
     */
    distinct?: SafeScalarFieldEnum | SafeScalarFieldEnum[]
  }

  /**
   * Safe findMany
   */
  export type SafeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter, which Safes to fetch.
     */
    where?: SafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Safes to fetch.
     */
    orderBy?: SafeOrderByWithRelationInput | SafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Safes.
     */
    cursor?: SafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Safes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Safes.
     */
    skip?: number
    distinct?: SafeScalarFieldEnum | SafeScalarFieldEnum[]
  }

  /**
   * Safe create
   */
  export type SafeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * The data needed to create a Safe.
     */
    data: XOR<SafeCreateInput, SafeUncheckedCreateInput>
  }

  /**
   * Safe createMany
   */
  export type SafeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Safes.
     */
    data: SafeCreateManyInput | SafeCreateManyInput[]
  }

  /**
   * Safe createManyAndReturn
   */
  export type SafeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * The data used to create many Safes.
     */
    data: SafeCreateManyInput | SafeCreateManyInput[]
  }

  /**
   * Safe update
   */
  export type SafeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * The data needed to update a Safe.
     */
    data: XOR<SafeUpdateInput, SafeUncheckedUpdateInput>
    /**
     * Choose, which Safe to update.
     */
    where: SafeWhereUniqueInput
  }

  /**
   * Safe updateMany
   */
  export type SafeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Safes.
     */
    data: XOR<SafeUpdateManyMutationInput, SafeUncheckedUpdateManyInput>
    /**
     * Filter which Safes to update
     */
    where?: SafeWhereInput
    /**
     * Limit how many Safes to update.
     */
    limit?: number
  }

  /**
   * Safe updateManyAndReturn
   */
  export type SafeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * The data used to update Safes.
     */
    data: XOR<SafeUpdateManyMutationInput, SafeUncheckedUpdateManyInput>
    /**
     * Filter which Safes to update
     */
    where?: SafeWhereInput
    /**
     * Limit how many Safes to update.
     */
    limit?: number
  }

  /**
   * Safe upsert
   */
  export type SafeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * The filter to search for the Safe to update in case it exists.
     */
    where: SafeWhereUniqueInput
    /**
     * In case the Safe found by the `where` argument doesn't exist, create a new Safe with this data.
     */
    create: XOR<SafeCreateInput, SafeUncheckedCreateInput>
    /**
     * In case the Safe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafeUpdateInput, SafeUncheckedUpdateInput>
  }

  /**
   * Safe delete
   */
  export type SafeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
    /**
     * Filter which Safe to delete.
     */
    where: SafeWhereUniqueInput
  }

  /**
   * Safe deleteMany
   */
  export type SafeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Safes to delete
     */
    where?: SafeWhereInput
    /**
     * Limit how many Safes to delete.
     */
    limit?: number
  }

  /**
   * Safe.vouchers
   */
  export type Safe$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Safe.transfersFrom
   */
  export type Safe$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Safe.transfersTo
   */
  export type Safe$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Safe without action
   */
  export type SafeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Safe
     */
    select?: SafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Safe
     */
    omit?: SafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafeInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransferSumAggregateOutputType = {
    amount: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    fromSafeId: string | null
    toSafeId: string | null
    amount: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    fromSafeId: string | null
    toSafeId: string | null
    amount: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    fromSafeId: number
    toSafeId: number
    amount: number
    description: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    amount?: true
  }

  export type TransferSumAggregateInputType = {
    amount?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    fromSafeId?: true
    toSafeId?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    fromSafeId?: true
    toSafeId?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    fromSafeId?: true
    toSafeId?: true
    amount?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    fromSafeId: string
    toSafeId: string
    amount: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromSafeId?: boolean
    toSafeId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromSafeId?: boolean
    toSafeId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromSafeId?: boolean
    toSafeId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    fromSafeId?: boolean
    toSafeId?: boolean
    amount?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromSafeId" | "toSafeId" | "amount" | "description" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromSafe?: boolean | SafeDefaultArgs<ExtArgs>
    toSafe?: boolean | SafeDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      fromSafe: Prisma.$SafePayload<ExtArgs>
      toSafe: Prisma.$SafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromSafeId: string
      toSafeId: string
      amount: number
      description: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromSafe<T extends SafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SafeDefaultArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toSafe<T extends SafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SafeDefaultArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly fromSafeId: FieldRef<"Transfer", 'String'>
    readonly toSafeId: FieldRef<"Transfer", 'String'>
    readonly amount: FieldRef<"Transfer", 'Float'>
    readonly description: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
    readonly deletedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    amount: number | null
  }

  export type VoucherSumAggregateOutputType = {
    amount: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    type: string | null
    date: Date | null
    amount: number | null
    safeId: string | null
    description: string | null
    payer: string | null
    beneficiary: string | null
    linkedRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    type: string | null
    date: Date | null
    amount: number | null
    safeId: string | null
    description: string | null
    payer: string | null
    beneficiary: string | null
    linkedRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    type: number
    date: number
    amount: number
    safeId: number
    description: number
    payer: number
    beneficiary: number
    linkedRef: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    amount?: true
  }

  export type VoucherSumAggregateInputType = {
    amount?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    safeId?: true
    description?: true
    payer?: true
    beneficiary?: true
    linkedRef?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    safeId?: true
    description?: true
    payer?: true
    beneficiary?: true
    linkedRef?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    safeId?: true
    description?: true
    payer?: true
    beneficiary?: true
    linkedRef?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    type: string
    date: Date
    amount: number
    safeId: string
    description: string
    payer: string | null
    beneficiary: string | null
    linkedRef: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    safeId?: boolean
    description?: boolean
    payer?: boolean
    beneficiary?: boolean
    linkedRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    safeId?: boolean
    description?: boolean
    payer?: boolean
    beneficiary?: boolean
    linkedRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    safeId?: boolean
    description?: boolean
    payer?: boolean
    beneficiary?: boolean
    linkedRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    safeId?: boolean
    description?: boolean
    payer?: boolean
    beneficiary?: boolean
    linkedRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "date" | "amount" | "safeId" | "description" | "payer" | "beneficiary" | "linkedRef" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | SafeDefaultArgs<ExtArgs>
    unit?: boolean | Voucher$unitArgs<ExtArgs>
  }

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      safe: Prisma.$SafePayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      date: Date
      amount: number
      safeId: string
      description: string
      payer: string | null
      beneficiary: string | null
      linkedRef: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    safe<T extends SafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SafeDefaultArgs<ExtArgs>>): Prisma__SafeClient<$Result.GetResult<Prisma.$SafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends Voucher$unitArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly type: FieldRef<"Voucher", 'String'>
    readonly date: FieldRef<"Voucher", 'DateTime'>
    readonly amount: FieldRef<"Voucher", 'Float'>
    readonly safeId: FieldRef<"Voucher", 'String'>
    readonly description: FieldRef<"Voucher", 'String'>
    readonly payer: FieldRef<"Voucher", 'String'>
    readonly beneficiary: FieldRef<"Voucher", 'String'>
    readonly linkedRef: FieldRef<"Voucher", 'String'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
    readonly deletedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.unit
   */
  export type Voucher$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model Broker
   */

  export type AggregateBroker = {
    _count: BrokerCountAggregateOutputType | null
    _min: BrokerMinAggregateOutputType | null
    _max: BrokerMaxAggregateOutputType | null
  }

  export type BrokerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BrokerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BrokerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BrokerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BrokerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BrokerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BrokerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Broker to aggregate.
     */
    where?: BrokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brokers to fetch.
     */
    orderBy?: BrokerOrderByWithRelationInput | BrokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brokers
    **/
    _count?: true | BrokerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrokerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrokerMaxAggregateInputType
  }

  export type GetBrokerAggregateType<T extends BrokerAggregateArgs> = {
        [P in keyof T & keyof AggregateBroker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBroker[P]>
      : GetScalarType<T[P], AggregateBroker[P]>
  }




  export type BrokerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrokerWhereInput
    orderBy?: BrokerOrderByWithAggregationInput | BrokerOrderByWithAggregationInput[]
    by: BrokerScalarFieldEnum[] | BrokerScalarFieldEnum
    having?: BrokerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrokerCountAggregateInputType | true
    _min?: BrokerMinAggregateInputType
    _max?: BrokerMaxAggregateInputType
  }

  export type BrokerGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BrokerCountAggregateOutputType | null
    _min: BrokerMinAggregateOutputType | null
    _max: BrokerMaxAggregateOutputType | null
  }

  type GetBrokerGroupByPayload<T extends BrokerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrokerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrokerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrokerGroupByOutputType[P]>
            : GetScalarType<T[P], BrokerGroupByOutputType[P]>
        }
      >
    >


  export type BrokerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    brokerDues?: boolean | Broker$brokerDuesArgs<ExtArgs>
    _count?: boolean | BrokerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["broker"]>

  export type BrokerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["broker"]>

  export type BrokerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["broker"]>

  export type BrokerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BrokerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["broker"]>
  export type BrokerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brokerDues?: boolean | Broker$brokerDuesArgs<ExtArgs>
    _count?: boolean | BrokerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrokerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrokerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrokerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Broker"
    objects: {
      brokerDues: Prisma.$BrokerDuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["broker"]>
    composites: {}
  }

  type BrokerGetPayload<S extends boolean | null | undefined | BrokerDefaultArgs> = $Result.GetResult<Prisma.$BrokerPayload, S>

  type BrokerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrokerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrokerCountAggregateInputType | true
    }

  export interface BrokerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Broker'], meta: { name: 'Broker' } }
    /**
     * Find zero or one Broker that matches the filter.
     * @param {BrokerFindUniqueArgs} args - Arguments to find a Broker
     * @example
     * // Get one Broker
     * const broker = await prisma.broker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrokerFindUniqueArgs>(args: SelectSubset<T, BrokerFindUniqueArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Broker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrokerFindUniqueOrThrowArgs} args - Arguments to find a Broker
     * @example
     * // Get one Broker
     * const broker = await prisma.broker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrokerFindUniqueOrThrowArgs>(args: SelectSubset<T, BrokerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Broker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerFindFirstArgs} args - Arguments to find a Broker
     * @example
     * // Get one Broker
     * const broker = await prisma.broker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrokerFindFirstArgs>(args?: SelectSubset<T, BrokerFindFirstArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Broker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerFindFirstOrThrowArgs} args - Arguments to find a Broker
     * @example
     * // Get one Broker
     * const broker = await prisma.broker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrokerFindFirstOrThrowArgs>(args?: SelectSubset<T, BrokerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brokers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brokers
     * const brokers = await prisma.broker.findMany()
     * 
     * // Get first 10 Brokers
     * const brokers = await prisma.broker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brokerWithIdOnly = await prisma.broker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrokerFindManyArgs>(args?: SelectSubset<T, BrokerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Broker.
     * @param {BrokerCreateArgs} args - Arguments to create a Broker.
     * @example
     * // Create one Broker
     * const Broker = await prisma.broker.create({
     *   data: {
     *     // ... data to create a Broker
     *   }
     * })
     * 
     */
    create<T extends BrokerCreateArgs>(args: SelectSubset<T, BrokerCreateArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brokers.
     * @param {BrokerCreateManyArgs} args - Arguments to create many Brokers.
     * @example
     * // Create many Brokers
     * const broker = await prisma.broker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrokerCreateManyArgs>(args?: SelectSubset<T, BrokerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brokers and returns the data saved in the database.
     * @param {BrokerCreateManyAndReturnArgs} args - Arguments to create many Brokers.
     * @example
     * // Create many Brokers
     * const broker = await prisma.broker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brokers and only return the `id`
     * const brokerWithIdOnly = await prisma.broker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrokerCreateManyAndReturnArgs>(args?: SelectSubset<T, BrokerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Broker.
     * @param {BrokerDeleteArgs} args - Arguments to delete one Broker.
     * @example
     * // Delete one Broker
     * const Broker = await prisma.broker.delete({
     *   where: {
     *     // ... filter to delete one Broker
     *   }
     * })
     * 
     */
    delete<T extends BrokerDeleteArgs>(args: SelectSubset<T, BrokerDeleteArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Broker.
     * @param {BrokerUpdateArgs} args - Arguments to update one Broker.
     * @example
     * // Update one Broker
     * const broker = await prisma.broker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrokerUpdateArgs>(args: SelectSubset<T, BrokerUpdateArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brokers.
     * @param {BrokerDeleteManyArgs} args - Arguments to filter Brokers to delete.
     * @example
     * // Delete a few Brokers
     * const { count } = await prisma.broker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrokerDeleteManyArgs>(args?: SelectSubset<T, BrokerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brokers
     * const broker = await prisma.broker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrokerUpdateManyArgs>(args: SelectSubset<T, BrokerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brokers and returns the data updated in the database.
     * @param {BrokerUpdateManyAndReturnArgs} args - Arguments to update many Brokers.
     * @example
     * // Update many Brokers
     * const broker = await prisma.broker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brokers and only return the `id`
     * const brokerWithIdOnly = await prisma.broker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrokerUpdateManyAndReturnArgs>(args: SelectSubset<T, BrokerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Broker.
     * @param {BrokerUpsertArgs} args - Arguments to update or create a Broker.
     * @example
     * // Update or create a Broker
     * const broker = await prisma.broker.upsert({
     *   create: {
     *     // ... data to create a Broker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Broker we want to update
     *   }
     * })
     */
    upsert<T extends BrokerUpsertArgs>(args: SelectSubset<T, BrokerUpsertArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerCountArgs} args - Arguments to filter Brokers to count.
     * @example
     * // Count the number of Brokers
     * const count = await prisma.broker.count({
     *   where: {
     *     // ... the filter for the Brokers we want to count
     *   }
     * })
    **/
    count<T extends BrokerCountArgs>(
      args?: Subset<T, BrokerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrokerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Broker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrokerAggregateArgs>(args: Subset<T, BrokerAggregateArgs>): Prisma.PrismaPromise<GetBrokerAggregateType<T>>

    /**
     * Group by Broker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrokerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrokerGroupByArgs['orderBy'] }
        : { orderBy?: BrokerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrokerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrokerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Broker model
   */
  readonly fields: BrokerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Broker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrokerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brokerDues<T extends Broker$brokerDuesArgs<ExtArgs> = {}>(args?: Subset<T, Broker$brokerDuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Broker model
   */
  interface BrokerFieldRefs {
    readonly id: FieldRef<"Broker", 'String'>
    readonly name: FieldRef<"Broker", 'String'>
    readonly phone: FieldRef<"Broker", 'String'>
    readonly notes: FieldRef<"Broker", 'String'>
    readonly createdAt: FieldRef<"Broker", 'DateTime'>
    readonly updatedAt: FieldRef<"Broker", 'DateTime'>
    readonly deletedAt: FieldRef<"Broker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Broker findUnique
   */
  export type BrokerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter, which Broker to fetch.
     */
    where: BrokerWhereUniqueInput
  }

  /**
   * Broker findUniqueOrThrow
   */
  export type BrokerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter, which Broker to fetch.
     */
    where: BrokerWhereUniqueInput
  }

  /**
   * Broker findFirst
   */
  export type BrokerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter, which Broker to fetch.
     */
    where?: BrokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brokers to fetch.
     */
    orderBy?: BrokerOrderByWithRelationInput | BrokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brokers.
     */
    cursor?: BrokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brokers.
     */
    distinct?: BrokerScalarFieldEnum | BrokerScalarFieldEnum[]
  }

  /**
   * Broker findFirstOrThrow
   */
  export type BrokerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter, which Broker to fetch.
     */
    where?: BrokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brokers to fetch.
     */
    orderBy?: BrokerOrderByWithRelationInput | BrokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brokers.
     */
    cursor?: BrokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brokers.
     */
    distinct?: BrokerScalarFieldEnum | BrokerScalarFieldEnum[]
  }

  /**
   * Broker findMany
   */
  export type BrokerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter, which Brokers to fetch.
     */
    where?: BrokerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brokers to fetch.
     */
    orderBy?: BrokerOrderByWithRelationInput | BrokerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brokers.
     */
    cursor?: BrokerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brokers.
     */
    skip?: number
    distinct?: BrokerScalarFieldEnum | BrokerScalarFieldEnum[]
  }

  /**
   * Broker create
   */
  export type BrokerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * The data needed to create a Broker.
     */
    data: XOR<BrokerCreateInput, BrokerUncheckedCreateInput>
  }

  /**
   * Broker createMany
   */
  export type BrokerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brokers.
     */
    data: BrokerCreateManyInput | BrokerCreateManyInput[]
  }

  /**
   * Broker createManyAndReturn
   */
  export type BrokerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * The data used to create many Brokers.
     */
    data: BrokerCreateManyInput | BrokerCreateManyInput[]
  }

  /**
   * Broker update
   */
  export type BrokerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * The data needed to update a Broker.
     */
    data: XOR<BrokerUpdateInput, BrokerUncheckedUpdateInput>
    /**
     * Choose, which Broker to update.
     */
    where: BrokerWhereUniqueInput
  }

  /**
   * Broker updateMany
   */
  export type BrokerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brokers.
     */
    data: XOR<BrokerUpdateManyMutationInput, BrokerUncheckedUpdateManyInput>
    /**
     * Filter which Brokers to update
     */
    where?: BrokerWhereInput
    /**
     * Limit how many Brokers to update.
     */
    limit?: number
  }

  /**
   * Broker updateManyAndReturn
   */
  export type BrokerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * The data used to update Brokers.
     */
    data: XOR<BrokerUpdateManyMutationInput, BrokerUncheckedUpdateManyInput>
    /**
     * Filter which Brokers to update
     */
    where?: BrokerWhereInput
    /**
     * Limit how many Brokers to update.
     */
    limit?: number
  }

  /**
   * Broker upsert
   */
  export type BrokerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * The filter to search for the Broker to update in case it exists.
     */
    where: BrokerWhereUniqueInput
    /**
     * In case the Broker found by the `where` argument doesn't exist, create a new Broker with this data.
     */
    create: XOR<BrokerCreateInput, BrokerUncheckedCreateInput>
    /**
     * In case the Broker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrokerUpdateInput, BrokerUncheckedUpdateInput>
  }

  /**
   * Broker delete
   */
  export type BrokerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
    /**
     * Filter which Broker to delete.
     */
    where: BrokerWhereUniqueInput
  }

  /**
   * Broker deleteMany
   */
  export type BrokerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brokers to delete
     */
    where?: BrokerWhereInput
    /**
     * Limit how many Brokers to delete.
     */
    limit?: number
  }

  /**
   * Broker.brokerDues
   */
  export type Broker$brokerDuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    where?: BrokerDueWhereInput
    orderBy?: BrokerDueOrderByWithRelationInput | BrokerDueOrderByWithRelationInput[]
    cursor?: BrokerDueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrokerDueScalarFieldEnum | BrokerDueScalarFieldEnum[]
  }

  /**
   * Broker without action
   */
  export type BrokerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Broker
     */
    select?: BrokerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Broker
     */
    omit?: BrokerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerInclude<ExtArgs> | null
  }


  /**
   * Model BrokerDue
   */

  export type AggregateBrokerDue = {
    _count: BrokerDueCountAggregateOutputType | null
    _avg: BrokerDueAvgAggregateOutputType | null
    _sum: BrokerDueSumAggregateOutputType | null
    _min: BrokerDueMinAggregateOutputType | null
    _max: BrokerDueMaxAggregateOutputType | null
  }

  export type BrokerDueAvgAggregateOutputType = {
    amount: number | null
  }

  export type BrokerDueSumAggregateOutputType = {
    amount: number | null
  }

  export type BrokerDueMinAggregateOutputType = {
    id: string | null
    brokerId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BrokerDueMaxAggregateOutputType = {
    id: string | null
    brokerId: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BrokerDueCountAggregateOutputType = {
    id: number
    brokerId: number
    amount: number
    dueDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BrokerDueAvgAggregateInputType = {
    amount?: true
  }

  export type BrokerDueSumAggregateInputType = {
    amount?: true
  }

  export type BrokerDueMinAggregateInputType = {
    id?: true
    brokerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BrokerDueMaxAggregateInputType = {
    id?: true
    brokerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BrokerDueCountAggregateInputType = {
    id?: true
    brokerId?: true
    amount?: true
    dueDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BrokerDueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrokerDue to aggregate.
     */
    where?: BrokerDueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrokerDues to fetch.
     */
    orderBy?: BrokerDueOrderByWithRelationInput | BrokerDueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrokerDueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrokerDues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrokerDues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BrokerDues
    **/
    _count?: true | BrokerDueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrokerDueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrokerDueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrokerDueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrokerDueMaxAggregateInputType
  }

  export type GetBrokerDueAggregateType<T extends BrokerDueAggregateArgs> = {
        [P in keyof T & keyof AggregateBrokerDue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrokerDue[P]>
      : GetScalarType<T[P], AggregateBrokerDue[P]>
  }




  export type BrokerDueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrokerDueWhereInput
    orderBy?: BrokerDueOrderByWithAggregationInput | BrokerDueOrderByWithAggregationInput[]
    by: BrokerDueScalarFieldEnum[] | BrokerDueScalarFieldEnum
    having?: BrokerDueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrokerDueCountAggregateInputType | true
    _avg?: BrokerDueAvgAggregateInputType
    _sum?: BrokerDueSumAggregateInputType
    _min?: BrokerDueMinAggregateInputType
    _max?: BrokerDueMaxAggregateInputType
  }

  export type BrokerDueGroupByOutputType = {
    id: string
    brokerId: string
    amount: number
    dueDate: Date
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BrokerDueCountAggregateOutputType | null
    _avg: BrokerDueAvgAggregateOutputType | null
    _sum: BrokerDueSumAggregateOutputType | null
    _min: BrokerDueMinAggregateOutputType | null
    _max: BrokerDueMaxAggregateOutputType | null
  }

  type GetBrokerDueGroupByPayload<T extends BrokerDueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrokerDueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrokerDueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrokerDueGroupByOutputType[P]>
            : GetScalarType<T[P], BrokerDueGroupByOutputType[P]>
        }
      >
    >


  export type BrokerDueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brokerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brokerDue"]>

  export type BrokerDueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brokerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brokerDue"]>

  export type BrokerDueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brokerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brokerDue"]>

  export type BrokerDueSelectScalar = {
    id?: boolean
    brokerId?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BrokerDueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brokerId" | "amount" | "dueDate" | "status" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["brokerDue"]>
  export type BrokerDueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }
  export type BrokerDueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }
  export type BrokerDueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broker?: boolean | BrokerDefaultArgs<ExtArgs>
  }

  export type $BrokerDuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BrokerDue"
    objects: {
      broker: Prisma.$BrokerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brokerId: string
      amount: number
      dueDate: Date
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["brokerDue"]>
    composites: {}
  }

  type BrokerDueGetPayload<S extends boolean | null | undefined | BrokerDueDefaultArgs> = $Result.GetResult<Prisma.$BrokerDuePayload, S>

  type BrokerDueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrokerDueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrokerDueCountAggregateInputType | true
    }

  export interface BrokerDueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BrokerDue'], meta: { name: 'BrokerDue' } }
    /**
     * Find zero or one BrokerDue that matches the filter.
     * @param {BrokerDueFindUniqueArgs} args - Arguments to find a BrokerDue
     * @example
     * // Get one BrokerDue
     * const brokerDue = await prisma.brokerDue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrokerDueFindUniqueArgs>(args: SelectSubset<T, BrokerDueFindUniqueArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BrokerDue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrokerDueFindUniqueOrThrowArgs} args - Arguments to find a BrokerDue
     * @example
     * // Get one BrokerDue
     * const brokerDue = await prisma.brokerDue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrokerDueFindUniqueOrThrowArgs>(args: SelectSubset<T, BrokerDueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BrokerDue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueFindFirstArgs} args - Arguments to find a BrokerDue
     * @example
     * // Get one BrokerDue
     * const brokerDue = await prisma.brokerDue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrokerDueFindFirstArgs>(args?: SelectSubset<T, BrokerDueFindFirstArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BrokerDue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueFindFirstOrThrowArgs} args - Arguments to find a BrokerDue
     * @example
     * // Get one BrokerDue
     * const brokerDue = await prisma.brokerDue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrokerDueFindFirstOrThrowArgs>(args?: SelectSubset<T, BrokerDueFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BrokerDues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BrokerDues
     * const brokerDues = await prisma.brokerDue.findMany()
     * 
     * // Get first 10 BrokerDues
     * const brokerDues = await prisma.brokerDue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brokerDueWithIdOnly = await prisma.brokerDue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrokerDueFindManyArgs>(args?: SelectSubset<T, BrokerDueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BrokerDue.
     * @param {BrokerDueCreateArgs} args - Arguments to create a BrokerDue.
     * @example
     * // Create one BrokerDue
     * const BrokerDue = await prisma.brokerDue.create({
     *   data: {
     *     // ... data to create a BrokerDue
     *   }
     * })
     * 
     */
    create<T extends BrokerDueCreateArgs>(args: SelectSubset<T, BrokerDueCreateArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BrokerDues.
     * @param {BrokerDueCreateManyArgs} args - Arguments to create many BrokerDues.
     * @example
     * // Create many BrokerDues
     * const brokerDue = await prisma.brokerDue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrokerDueCreateManyArgs>(args?: SelectSubset<T, BrokerDueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BrokerDues and returns the data saved in the database.
     * @param {BrokerDueCreateManyAndReturnArgs} args - Arguments to create many BrokerDues.
     * @example
     * // Create many BrokerDues
     * const brokerDue = await prisma.brokerDue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BrokerDues and only return the `id`
     * const brokerDueWithIdOnly = await prisma.brokerDue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrokerDueCreateManyAndReturnArgs>(args?: SelectSubset<T, BrokerDueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BrokerDue.
     * @param {BrokerDueDeleteArgs} args - Arguments to delete one BrokerDue.
     * @example
     * // Delete one BrokerDue
     * const BrokerDue = await prisma.brokerDue.delete({
     *   where: {
     *     // ... filter to delete one BrokerDue
     *   }
     * })
     * 
     */
    delete<T extends BrokerDueDeleteArgs>(args: SelectSubset<T, BrokerDueDeleteArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BrokerDue.
     * @param {BrokerDueUpdateArgs} args - Arguments to update one BrokerDue.
     * @example
     * // Update one BrokerDue
     * const brokerDue = await prisma.brokerDue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrokerDueUpdateArgs>(args: SelectSubset<T, BrokerDueUpdateArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BrokerDues.
     * @param {BrokerDueDeleteManyArgs} args - Arguments to filter BrokerDues to delete.
     * @example
     * // Delete a few BrokerDues
     * const { count } = await prisma.brokerDue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrokerDueDeleteManyArgs>(args?: SelectSubset<T, BrokerDueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BrokerDues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BrokerDues
     * const brokerDue = await prisma.brokerDue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrokerDueUpdateManyArgs>(args: SelectSubset<T, BrokerDueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BrokerDues and returns the data updated in the database.
     * @param {BrokerDueUpdateManyAndReturnArgs} args - Arguments to update many BrokerDues.
     * @example
     * // Update many BrokerDues
     * const brokerDue = await prisma.brokerDue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BrokerDues and only return the `id`
     * const brokerDueWithIdOnly = await prisma.brokerDue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrokerDueUpdateManyAndReturnArgs>(args: SelectSubset<T, BrokerDueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BrokerDue.
     * @param {BrokerDueUpsertArgs} args - Arguments to update or create a BrokerDue.
     * @example
     * // Update or create a BrokerDue
     * const brokerDue = await prisma.brokerDue.upsert({
     *   create: {
     *     // ... data to create a BrokerDue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BrokerDue we want to update
     *   }
     * })
     */
    upsert<T extends BrokerDueUpsertArgs>(args: SelectSubset<T, BrokerDueUpsertArgs<ExtArgs>>): Prisma__BrokerDueClient<$Result.GetResult<Prisma.$BrokerDuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BrokerDues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueCountArgs} args - Arguments to filter BrokerDues to count.
     * @example
     * // Count the number of BrokerDues
     * const count = await prisma.brokerDue.count({
     *   where: {
     *     // ... the filter for the BrokerDues we want to count
     *   }
     * })
    **/
    count<T extends BrokerDueCountArgs>(
      args?: Subset<T, BrokerDueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrokerDueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BrokerDue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrokerDueAggregateArgs>(args: Subset<T, BrokerDueAggregateArgs>): Prisma.PrismaPromise<GetBrokerDueAggregateType<T>>

    /**
     * Group by BrokerDue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokerDueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrokerDueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrokerDueGroupByArgs['orderBy'] }
        : { orderBy?: BrokerDueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrokerDueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrokerDueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BrokerDue model
   */
  readonly fields: BrokerDueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BrokerDue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrokerDueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broker<T extends BrokerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrokerDefaultArgs<ExtArgs>>): Prisma__BrokerClient<$Result.GetResult<Prisma.$BrokerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BrokerDue model
   */
  interface BrokerDueFieldRefs {
    readonly id: FieldRef<"BrokerDue", 'String'>
    readonly brokerId: FieldRef<"BrokerDue", 'String'>
    readonly amount: FieldRef<"BrokerDue", 'Float'>
    readonly dueDate: FieldRef<"BrokerDue", 'DateTime'>
    readonly status: FieldRef<"BrokerDue", 'String'>
    readonly notes: FieldRef<"BrokerDue", 'String'>
    readonly createdAt: FieldRef<"BrokerDue", 'DateTime'>
    readonly updatedAt: FieldRef<"BrokerDue", 'DateTime'>
    readonly deletedAt: FieldRef<"BrokerDue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BrokerDue findUnique
   */
  export type BrokerDueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter, which BrokerDue to fetch.
     */
    where: BrokerDueWhereUniqueInput
  }

  /**
   * BrokerDue findUniqueOrThrow
   */
  export type BrokerDueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter, which BrokerDue to fetch.
     */
    where: BrokerDueWhereUniqueInput
  }

  /**
   * BrokerDue findFirst
   */
  export type BrokerDueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter, which BrokerDue to fetch.
     */
    where?: BrokerDueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrokerDues to fetch.
     */
    orderBy?: BrokerDueOrderByWithRelationInput | BrokerDueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrokerDues.
     */
    cursor?: BrokerDueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrokerDues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrokerDues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrokerDues.
     */
    distinct?: BrokerDueScalarFieldEnum | BrokerDueScalarFieldEnum[]
  }

  /**
   * BrokerDue findFirstOrThrow
   */
  export type BrokerDueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter, which BrokerDue to fetch.
     */
    where?: BrokerDueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrokerDues to fetch.
     */
    orderBy?: BrokerDueOrderByWithRelationInput | BrokerDueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrokerDues.
     */
    cursor?: BrokerDueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrokerDues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrokerDues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrokerDues.
     */
    distinct?: BrokerDueScalarFieldEnum | BrokerDueScalarFieldEnum[]
  }

  /**
   * BrokerDue findMany
   */
  export type BrokerDueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter, which BrokerDues to fetch.
     */
    where?: BrokerDueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrokerDues to fetch.
     */
    orderBy?: BrokerDueOrderByWithRelationInput | BrokerDueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BrokerDues.
     */
    cursor?: BrokerDueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrokerDues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrokerDues.
     */
    skip?: number
    distinct?: BrokerDueScalarFieldEnum | BrokerDueScalarFieldEnum[]
  }

  /**
   * BrokerDue create
   */
  export type BrokerDueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * The data needed to create a BrokerDue.
     */
    data: XOR<BrokerDueCreateInput, BrokerDueUncheckedCreateInput>
  }

  /**
   * BrokerDue createMany
   */
  export type BrokerDueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BrokerDues.
     */
    data: BrokerDueCreateManyInput | BrokerDueCreateManyInput[]
  }

  /**
   * BrokerDue createManyAndReturn
   */
  export type BrokerDueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * The data used to create many BrokerDues.
     */
    data: BrokerDueCreateManyInput | BrokerDueCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BrokerDue update
   */
  export type BrokerDueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * The data needed to update a BrokerDue.
     */
    data: XOR<BrokerDueUpdateInput, BrokerDueUncheckedUpdateInput>
    /**
     * Choose, which BrokerDue to update.
     */
    where: BrokerDueWhereUniqueInput
  }

  /**
   * BrokerDue updateMany
   */
  export type BrokerDueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BrokerDues.
     */
    data: XOR<BrokerDueUpdateManyMutationInput, BrokerDueUncheckedUpdateManyInput>
    /**
     * Filter which BrokerDues to update
     */
    where?: BrokerDueWhereInput
    /**
     * Limit how many BrokerDues to update.
     */
    limit?: number
  }

  /**
   * BrokerDue updateManyAndReturn
   */
  export type BrokerDueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * The data used to update BrokerDues.
     */
    data: XOR<BrokerDueUpdateManyMutationInput, BrokerDueUncheckedUpdateManyInput>
    /**
     * Filter which BrokerDues to update
     */
    where?: BrokerDueWhereInput
    /**
     * Limit how many BrokerDues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BrokerDue upsert
   */
  export type BrokerDueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * The filter to search for the BrokerDue to update in case it exists.
     */
    where: BrokerDueWhereUniqueInput
    /**
     * In case the BrokerDue found by the `where` argument doesn't exist, create a new BrokerDue with this data.
     */
    create: XOR<BrokerDueCreateInput, BrokerDueUncheckedCreateInput>
    /**
     * In case the BrokerDue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrokerDueUpdateInput, BrokerDueUncheckedUpdateInput>
  }

  /**
   * BrokerDue delete
   */
  export type BrokerDueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
    /**
     * Filter which BrokerDue to delete.
     */
    where: BrokerDueWhereUniqueInput
  }

  /**
   * BrokerDue deleteMany
   */
  export type BrokerDueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrokerDues to delete
     */
    where?: BrokerDueWhereInput
    /**
     * Limit how many BrokerDues to delete.
     */
    limit?: number
  }

  /**
   * BrokerDue without action
   */
  export type BrokerDueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrokerDue
     */
    select?: BrokerDueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrokerDue
     */
    omit?: BrokerDueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrokerDueInclude<ExtArgs> | null
  }


  /**
   * Model PartnerGroup
   */

  export type AggregatePartnerGroup = {
    _count: PartnerGroupCountAggregateOutputType | null
    _min: PartnerGroupMinAggregateOutputType | null
    _max: PartnerGroupMaxAggregateOutputType | null
  }

  export type PartnerGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerGroupCountAggregateOutputType = {
    id: number
    name: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PartnerGroupMinAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerGroupMaxAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerGroupCountAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PartnerGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerGroup to aggregate.
     */
    where?: PartnerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroups to fetch.
     */
    orderBy?: PartnerGroupOrderByWithRelationInput | PartnerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerGroups
    **/
    _count?: true | PartnerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerGroupMaxAggregateInputType
  }

  export type GetPartnerGroupAggregateType<T extends PartnerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerGroup[P]>
      : GetScalarType<T[P], AggregatePartnerGroup[P]>
  }




  export type PartnerGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerGroupWhereInput
    orderBy?: PartnerGroupOrderByWithAggregationInput | PartnerGroupOrderByWithAggregationInput[]
    by: PartnerGroupScalarFieldEnum[] | PartnerGroupScalarFieldEnum
    having?: PartnerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerGroupCountAggregateInputType | true
    _min?: PartnerGroupMinAggregateInputType
    _max?: PartnerGroupMaxAggregateInputType
  }

  export type PartnerGroupGroupByOutputType = {
    id: string
    name: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PartnerGroupCountAggregateOutputType | null
    _min: PartnerGroupMinAggregateOutputType | null
    _max: PartnerGroupMaxAggregateOutputType | null
  }

  type GetPartnerGroupGroupByPayload<T extends PartnerGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupGroupByOutputType[P]>
        }
      >
    >


  export type PartnerGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partners?: boolean | PartnerGroup$partnersArgs<ExtArgs>
    _count?: boolean | PartnerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerGroup"]>

  export type PartnerGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["partnerGroup"]>

  export type PartnerGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["partnerGroup"]>

  export type PartnerGroupSelectScalar = {
    id?: boolean
    name?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PartnerGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["partnerGroup"]>
  export type PartnerGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partners?: boolean | PartnerGroup$partnersArgs<ExtArgs>
    _count?: boolean | PartnerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PartnerGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerGroup"
    objects: {
      partners: Prisma.$PartnerGroupPartnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["partnerGroup"]>
    composites: {}
  }

  type PartnerGroupGetPayload<S extends boolean | null | undefined | PartnerGroupDefaultArgs> = $Result.GetResult<Prisma.$PartnerGroupPayload, S>

  type PartnerGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerGroupCountAggregateInputType | true
    }

  export interface PartnerGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerGroup'], meta: { name: 'PartnerGroup' } }
    /**
     * Find zero or one PartnerGroup that matches the filter.
     * @param {PartnerGroupFindUniqueArgs} args - Arguments to find a PartnerGroup
     * @example
     * // Get one PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerGroupFindUniqueArgs>(args: SelectSubset<T, PartnerGroupFindUniqueArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerGroupFindUniqueOrThrowArgs} args - Arguments to find a PartnerGroup
     * @example
     * // Get one PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupFindFirstArgs} args - Arguments to find a PartnerGroup
     * @example
     * // Get one PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerGroupFindFirstArgs>(args?: SelectSubset<T, PartnerGroupFindFirstArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupFindFirstOrThrowArgs} args - Arguments to find a PartnerGroup
     * @example
     * // Get one PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerGroups
     * const partnerGroups = await prisma.partnerGroup.findMany()
     * 
     * // Get first 10 PartnerGroups
     * const partnerGroups = await prisma.partnerGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerGroupWithIdOnly = await prisma.partnerGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerGroupFindManyArgs>(args?: SelectSubset<T, PartnerGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerGroup.
     * @param {PartnerGroupCreateArgs} args - Arguments to create a PartnerGroup.
     * @example
     * // Create one PartnerGroup
     * const PartnerGroup = await prisma.partnerGroup.create({
     *   data: {
     *     // ... data to create a PartnerGroup
     *   }
     * })
     * 
     */
    create<T extends PartnerGroupCreateArgs>(args: SelectSubset<T, PartnerGroupCreateArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerGroups.
     * @param {PartnerGroupCreateManyArgs} args - Arguments to create many PartnerGroups.
     * @example
     * // Create many PartnerGroups
     * const partnerGroup = await prisma.partnerGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerGroupCreateManyArgs>(args?: SelectSubset<T, PartnerGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerGroups and returns the data saved in the database.
     * @param {PartnerGroupCreateManyAndReturnArgs} args - Arguments to create many PartnerGroups.
     * @example
     * // Create many PartnerGroups
     * const partnerGroup = await prisma.partnerGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerGroups and only return the `id`
     * const partnerGroupWithIdOnly = await prisma.partnerGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerGroup.
     * @param {PartnerGroupDeleteArgs} args - Arguments to delete one PartnerGroup.
     * @example
     * // Delete one PartnerGroup
     * const PartnerGroup = await prisma.partnerGroup.delete({
     *   where: {
     *     // ... filter to delete one PartnerGroup
     *   }
     * })
     * 
     */
    delete<T extends PartnerGroupDeleteArgs>(args: SelectSubset<T, PartnerGroupDeleteArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerGroup.
     * @param {PartnerGroupUpdateArgs} args - Arguments to update one PartnerGroup.
     * @example
     * // Update one PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerGroupUpdateArgs>(args: SelectSubset<T, PartnerGroupUpdateArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerGroups.
     * @param {PartnerGroupDeleteManyArgs} args - Arguments to filter PartnerGroups to delete.
     * @example
     * // Delete a few PartnerGroups
     * const { count } = await prisma.partnerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerGroupDeleteManyArgs>(args?: SelectSubset<T, PartnerGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerGroups
     * const partnerGroup = await prisma.partnerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerGroupUpdateManyArgs>(args: SelectSubset<T, PartnerGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerGroups and returns the data updated in the database.
     * @param {PartnerGroupUpdateManyAndReturnArgs} args - Arguments to update many PartnerGroups.
     * @example
     * // Update many PartnerGroups
     * const partnerGroup = await prisma.partnerGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerGroups and only return the `id`
     * const partnerGroupWithIdOnly = await prisma.partnerGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerGroup.
     * @param {PartnerGroupUpsertArgs} args - Arguments to update or create a PartnerGroup.
     * @example
     * // Update or create a PartnerGroup
     * const partnerGroup = await prisma.partnerGroup.upsert({
     *   create: {
     *     // ... data to create a PartnerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerGroup we want to update
     *   }
     * })
     */
    upsert<T extends PartnerGroupUpsertArgs>(args: SelectSubset<T, PartnerGroupUpsertArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupCountArgs} args - Arguments to filter PartnerGroups to count.
     * @example
     * // Count the number of PartnerGroups
     * const count = await prisma.partnerGroup.count({
     *   where: {
     *     // ... the filter for the PartnerGroups we want to count
     *   }
     * })
    **/
    count<T extends PartnerGroupCountArgs>(
      args?: Subset<T, PartnerGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerGroupAggregateArgs>(args: Subset<T, PartnerGroupAggregateArgs>): Prisma.PrismaPromise<GetPartnerGroupAggregateType<T>>

    /**
     * Group by PartnerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerGroup model
   */
  readonly fields: PartnerGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partners<T extends PartnerGroup$partnersArgs<ExtArgs> = {}>(args?: Subset<T, PartnerGroup$partnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerGroup model
   */
  interface PartnerGroupFieldRefs {
    readonly id: FieldRef<"PartnerGroup", 'String'>
    readonly name: FieldRef<"PartnerGroup", 'String'>
    readonly notes: FieldRef<"PartnerGroup", 'String'>
    readonly createdAt: FieldRef<"PartnerGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerGroup", 'DateTime'>
    readonly deletedAt: FieldRef<"PartnerGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerGroup findUnique
   */
  export type PartnerGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroup to fetch.
     */
    where: PartnerGroupWhereUniqueInput
  }

  /**
   * PartnerGroup findUniqueOrThrow
   */
  export type PartnerGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroup to fetch.
     */
    where: PartnerGroupWhereUniqueInput
  }

  /**
   * PartnerGroup findFirst
   */
  export type PartnerGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroup to fetch.
     */
    where?: PartnerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroups to fetch.
     */
    orderBy?: PartnerGroupOrderByWithRelationInput | PartnerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerGroups.
     */
    cursor?: PartnerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerGroups.
     */
    distinct?: PartnerGroupScalarFieldEnum | PartnerGroupScalarFieldEnum[]
  }

  /**
   * PartnerGroup findFirstOrThrow
   */
  export type PartnerGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroup to fetch.
     */
    where?: PartnerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroups to fetch.
     */
    orderBy?: PartnerGroupOrderByWithRelationInput | PartnerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerGroups.
     */
    cursor?: PartnerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerGroups.
     */
    distinct?: PartnerGroupScalarFieldEnum | PartnerGroupScalarFieldEnum[]
  }

  /**
   * PartnerGroup findMany
   */
  export type PartnerGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroups to fetch.
     */
    where?: PartnerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroups to fetch.
     */
    orderBy?: PartnerGroupOrderByWithRelationInput | PartnerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerGroups.
     */
    cursor?: PartnerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroups.
     */
    skip?: number
    distinct?: PartnerGroupScalarFieldEnum | PartnerGroupScalarFieldEnum[]
  }

  /**
   * PartnerGroup create
   */
  export type PartnerGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerGroup.
     */
    data: XOR<PartnerGroupCreateInput, PartnerGroupUncheckedCreateInput>
  }

  /**
   * PartnerGroup createMany
   */
  export type PartnerGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerGroups.
     */
    data: PartnerGroupCreateManyInput | PartnerGroupCreateManyInput[]
  }

  /**
   * PartnerGroup createManyAndReturn
   */
  export type PartnerGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerGroups.
     */
    data: PartnerGroupCreateManyInput | PartnerGroupCreateManyInput[]
  }

  /**
   * PartnerGroup update
   */
  export type PartnerGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerGroup.
     */
    data: XOR<PartnerGroupUpdateInput, PartnerGroupUncheckedUpdateInput>
    /**
     * Choose, which PartnerGroup to update.
     */
    where: PartnerGroupWhereUniqueInput
  }

  /**
   * PartnerGroup updateMany
   */
  export type PartnerGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerGroups.
     */
    data: XOR<PartnerGroupUpdateManyMutationInput, PartnerGroupUncheckedUpdateManyInput>
    /**
     * Filter which PartnerGroups to update
     */
    where?: PartnerGroupWhereInput
    /**
     * Limit how many PartnerGroups to update.
     */
    limit?: number
  }

  /**
   * PartnerGroup updateManyAndReturn
   */
  export type PartnerGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * The data used to update PartnerGroups.
     */
    data: XOR<PartnerGroupUpdateManyMutationInput, PartnerGroupUncheckedUpdateManyInput>
    /**
     * Filter which PartnerGroups to update
     */
    where?: PartnerGroupWhereInput
    /**
     * Limit how many PartnerGroups to update.
     */
    limit?: number
  }

  /**
   * PartnerGroup upsert
   */
  export type PartnerGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerGroup to update in case it exists.
     */
    where: PartnerGroupWhereUniqueInput
    /**
     * In case the PartnerGroup found by the `where` argument doesn't exist, create a new PartnerGroup with this data.
     */
    create: XOR<PartnerGroupCreateInput, PartnerGroupUncheckedCreateInput>
    /**
     * In case the PartnerGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerGroupUpdateInput, PartnerGroupUncheckedUpdateInput>
  }

  /**
   * PartnerGroup delete
   */
  export type PartnerGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
    /**
     * Filter which PartnerGroup to delete.
     */
    where: PartnerGroupWhereUniqueInput
  }

  /**
   * PartnerGroup deleteMany
   */
  export type PartnerGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerGroups to delete
     */
    where?: PartnerGroupWhereInput
    /**
     * Limit how many PartnerGroups to delete.
     */
    limit?: number
  }

  /**
   * PartnerGroup.partners
   */
  export type PartnerGroup$partnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    where?: PartnerGroupPartnerWhereInput
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    cursor?: PartnerGroupPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerGroupPartnerScalarFieldEnum | PartnerGroupPartnerScalarFieldEnum[]
  }

  /**
   * PartnerGroup without action
   */
  export type PartnerGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroup
     */
    select?: PartnerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroup
     */
    omit?: PartnerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupInclude<ExtArgs> | null
  }


  /**
   * Model PartnerGroupPartner
   */

  export type AggregatePartnerGroupPartner = {
    _count: PartnerGroupPartnerCountAggregateOutputType | null
    _avg: PartnerGroupPartnerAvgAggregateOutputType | null
    _sum: PartnerGroupPartnerSumAggregateOutputType | null
    _min: PartnerGroupPartnerMinAggregateOutputType | null
    _max: PartnerGroupPartnerMaxAggregateOutputType | null
  }

  export type PartnerGroupPartnerAvgAggregateOutputType = {
    percentage: number | null
  }

  export type PartnerGroupPartnerSumAggregateOutputType = {
    percentage: number | null
  }

  export type PartnerGroupPartnerMinAggregateOutputType = {
    id: string | null
    partnerGroupId: string | null
    partnerId: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerGroupPartnerMaxAggregateOutputType = {
    id: string | null
    partnerGroupId: string | null
    partnerId: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PartnerGroupPartnerCountAggregateOutputType = {
    id: number
    partnerGroupId: number
    partnerId: number
    percentage: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PartnerGroupPartnerAvgAggregateInputType = {
    percentage?: true
  }

  export type PartnerGroupPartnerSumAggregateInputType = {
    percentage?: true
  }

  export type PartnerGroupPartnerMinAggregateInputType = {
    id?: true
    partnerGroupId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerGroupPartnerMaxAggregateInputType = {
    id?: true
    partnerGroupId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PartnerGroupPartnerCountAggregateInputType = {
    id?: true
    partnerGroupId?: true
    partnerId?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PartnerGroupPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerGroupPartner to aggregate.
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroupPartners to fetch.
     */
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerGroupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerGroupPartners
    **/
    _count?: true | PartnerGroupPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerGroupPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerGroupPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerGroupPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerGroupPartnerMaxAggregateInputType
  }

  export type GetPartnerGroupPartnerAggregateType<T extends PartnerGroupPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerGroupPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerGroupPartner[P]>
      : GetScalarType<T[P], AggregatePartnerGroupPartner[P]>
  }




  export type PartnerGroupPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerGroupPartnerWhereInput
    orderBy?: PartnerGroupPartnerOrderByWithAggregationInput | PartnerGroupPartnerOrderByWithAggregationInput[]
    by: PartnerGroupPartnerScalarFieldEnum[] | PartnerGroupPartnerScalarFieldEnum
    having?: PartnerGroupPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerGroupPartnerCountAggregateInputType | true
    _avg?: PartnerGroupPartnerAvgAggregateInputType
    _sum?: PartnerGroupPartnerSumAggregateInputType
    _min?: PartnerGroupPartnerMinAggregateInputType
    _max?: PartnerGroupPartnerMaxAggregateInputType
  }

  export type PartnerGroupPartnerGroupByOutputType = {
    id: string
    partnerGroupId: string
    partnerId: string
    percentage: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PartnerGroupPartnerCountAggregateOutputType | null
    _avg: PartnerGroupPartnerAvgAggregateOutputType | null
    _sum: PartnerGroupPartnerSumAggregateOutputType | null
    _min: PartnerGroupPartnerMinAggregateOutputType | null
    _max: PartnerGroupPartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupPartnerGroupByPayload<T extends PartnerGroupPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupPartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerGroupPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerGroupId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerGroupPartner"]>

  export type PartnerGroupPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerGroupId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerGroupPartner"]>

  export type PartnerGroupPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerGroupId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerGroupPartner"]>

  export type PartnerGroupPartnerSelectScalar = {
    id?: boolean
    partnerGroupId?: boolean
    partnerId?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PartnerGroupPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerGroupId" | "partnerId" | "percentage" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["partnerGroupPartner"]>
  export type PartnerGroupPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerGroupPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerGroupPartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partnerGroup?: boolean | PartnerGroupDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerGroupPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerGroupPartner"
    objects: {
      partnerGroup: Prisma.$PartnerGroupPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerGroupId: string
      partnerId: string
      percentage: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["partnerGroupPartner"]>
    composites: {}
  }

  type PartnerGroupPartnerGetPayload<S extends boolean | null | undefined | PartnerGroupPartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerGroupPartnerPayload, S>

  type PartnerGroupPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerGroupPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerGroupPartnerCountAggregateInputType | true
    }

  export interface PartnerGroupPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerGroupPartner'], meta: { name: 'PartnerGroupPartner' } }
    /**
     * Find zero or one PartnerGroupPartner that matches the filter.
     * @param {PartnerGroupPartnerFindUniqueArgs} args - Arguments to find a PartnerGroupPartner
     * @example
     * // Get one PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerGroupPartnerFindUniqueArgs>(args: SelectSubset<T, PartnerGroupPartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerGroupPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerGroupPartnerFindUniqueOrThrowArgs} args - Arguments to find a PartnerGroupPartner
     * @example
     * // Get one PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerGroupPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerGroupPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerGroupPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerFindFirstArgs} args - Arguments to find a PartnerGroupPartner
     * @example
     * // Get one PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerGroupPartnerFindFirstArgs>(args?: SelectSubset<T, PartnerGroupPartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerGroupPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerFindFirstOrThrowArgs} args - Arguments to find a PartnerGroupPartner
     * @example
     * // Get one PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerGroupPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerGroupPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerGroupPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerGroupPartners
     * const partnerGroupPartners = await prisma.partnerGroupPartner.findMany()
     * 
     * // Get first 10 PartnerGroupPartners
     * const partnerGroupPartners = await prisma.partnerGroupPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerGroupPartnerWithIdOnly = await prisma.partnerGroupPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerGroupPartnerFindManyArgs>(args?: SelectSubset<T, PartnerGroupPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerGroupPartner.
     * @param {PartnerGroupPartnerCreateArgs} args - Arguments to create a PartnerGroupPartner.
     * @example
     * // Create one PartnerGroupPartner
     * const PartnerGroupPartner = await prisma.partnerGroupPartner.create({
     *   data: {
     *     // ... data to create a PartnerGroupPartner
     *   }
     * })
     * 
     */
    create<T extends PartnerGroupPartnerCreateArgs>(args: SelectSubset<T, PartnerGroupPartnerCreateArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerGroupPartners.
     * @param {PartnerGroupPartnerCreateManyArgs} args - Arguments to create many PartnerGroupPartners.
     * @example
     * // Create many PartnerGroupPartners
     * const partnerGroupPartner = await prisma.partnerGroupPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerGroupPartnerCreateManyArgs>(args?: SelectSubset<T, PartnerGroupPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerGroupPartners and returns the data saved in the database.
     * @param {PartnerGroupPartnerCreateManyAndReturnArgs} args - Arguments to create many PartnerGroupPartners.
     * @example
     * // Create many PartnerGroupPartners
     * const partnerGroupPartner = await prisma.partnerGroupPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerGroupPartners and only return the `id`
     * const partnerGroupPartnerWithIdOnly = await prisma.partnerGroupPartner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerGroupPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerGroupPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerGroupPartner.
     * @param {PartnerGroupPartnerDeleteArgs} args - Arguments to delete one PartnerGroupPartner.
     * @example
     * // Delete one PartnerGroupPartner
     * const PartnerGroupPartner = await prisma.partnerGroupPartner.delete({
     *   where: {
     *     // ... filter to delete one PartnerGroupPartner
     *   }
     * })
     * 
     */
    delete<T extends PartnerGroupPartnerDeleteArgs>(args: SelectSubset<T, PartnerGroupPartnerDeleteArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerGroupPartner.
     * @param {PartnerGroupPartnerUpdateArgs} args - Arguments to update one PartnerGroupPartner.
     * @example
     * // Update one PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerGroupPartnerUpdateArgs>(args: SelectSubset<T, PartnerGroupPartnerUpdateArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerGroupPartners.
     * @param {PartnerGroupPartnerDeleteManyArgs} args - Arguments to filter PartnerGroupPartners to delete.
     * @example
     * // Delete a few PartnerGroupPartners
     * const { count } = await prisma.partnerGroupPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerGroupPartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerGroupPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerGroupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerGroupPartners
     * const partnerGroupPartner = await prisma.partnerGroupPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerGroupPartnerUpdateManyArgs>(args: SelectSubset<T, PartnerGroupPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerGroupPartners and returns the data updated in the database.
     * @param {PartnerGroupPartnerUpdateManyAndReturnArgs} args - Arguments to update many PartnerGroupPartners.
     * @example
     * // Update many PartnerGroupPartners
     * const partnerGroupPartner = await prisma.partnerGroupPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerGroupPartners and only return the `id`
     * const partnerGroupPartnerWithIdOnly = await prisma.partnerGroupPartner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerGroupPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerGroupPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerGroupPartner.
     * @param {PartnerGroupPartnerUpsertArgs} args - Arguments to update or create a PartnerGroupPartner.
     * @example
     * // Update or create a PartnerGroupPartner
     * const partnerGroupPartner = await prisma.partnerGroupPartner.upsert({
     *   create: {
     *     // ... data to create a PartnerGroupPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerGroupPartner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerGroupPartnerUpsertArgs>(args: SelectSubset<T, PartnerGroupPartnerUpsertArgs<ExtArgs>>): Prisma__PartnerGroupPartnerClient<$Result.GetResult<Prisma.$PartnerGroupPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerGroupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerCountArgs} args - Arguments to filter PartnerGroupPartners to count.
     * @example
     * // Count the number of PartnerGroupPartners
     * const count = await prisma.partnerGroupPartner.count({
     *   where: {
     *     // ... the filter for the PartnerGroupPartners we want to count
     *   }
     * })
    **/
    count<T extends PartnerGroupPartnerCountArgs>(
      args?: Subset<T, PartnerGroupPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerGroupPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerGroupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerGroupPartnerAggregateArgs>(args: Subset<T, PartnerGroupPartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerGroupPartnerAggregateType<T>>

    /**
     * Group by PartnerGroupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupPartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerGroupPartner model
   */
  readonly fields: PartnerGroupPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerGroupPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerGroupPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partnerGroup<T extends PartnerGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerGroupDefaultArgs<ExtArgs>>): Prisma__PartnerGroupClient<$Result.GetResult<Prisma.$PartnerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerGroupPartner model
   */
  interface PartnerGroupPartnerFieldRefs {
    readonly id: FieldRef<"PartnerGroupPartner", 'String'>
    readonly partnerGroupId: FieldRef<"PartnerGroupPartner", 'String'>
    readonly partnerId: FieldRef<"PartnerGroupPartner", 'String'>
    readonly percentage: FieldRef<"PartnerGroupPartner", 'Float'>
    readonly createdAt: FieldRef<"PartnerGroupPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerGroupPartner", 'DateTime'>
    readonly deletedAt: FieldRef<"PartnerGroupPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerGroupPartner findUnique
   */
  export type PartnerGroupPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroupPartner to fetch.
     */
    where: PartnerGroupPartnerWhereUniqueInput
  }

  /**
   * PartnerGroupPartner findUniqueOrThrow
   */
  export type PartnerGroupPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroupPartner to fetch.
     */
    where: PartnerGroupPartnerWhereUniqueInput
  }

  /**
   * PartnerGroupPartner findFirst
   */
  export type PartnerGroupPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroupPartner to fetch.
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroupPartners to fetch.
     */
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerGroupPartners.
     */
    cursor?: PartnerGroupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerGroupPartners.
     */
    distinct?: PartnerGroupPartnerScalarFieldEnum | PartnerGroupPartnerScalarFieldEnum[]
  }

  /**
   * PartnerGroupPartner findFirstOrThrow
   */
  export type PartnerGroupPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroupPartner to fetch.
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroupPartners to fetch.
     */
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerGroupPartners.
     */
    cursor?: PartnerGroupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerGroupPartners.
     */
    distinct?: PartnerGroupPartnerScalarFieldEnum | PartnerGroupPartnerScalarFieldEnum[]
  }

  /**
   * PartnerGroupPartner findMany
   */
  export type PartnerGroupPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which PartnerGroupPartners to fetch.
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerGroupPartners to fetch.
     */
    orderBy?: PartnerGroupPartnerOrderByWithRelationInput | PartnerGroupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerGroupPartners.
     */
    cursor?: PartnerGroupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerGroupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerGroupPartners.
     */
    skip?: number
    distinct?: PartnerGroupPartnerScalarFieldEnum | PartnerGroupPartnerScalarFieldEnum[]
  }

  /**
   * PartnerGroupPartner create
   */
  export type PartnerGroupPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerGroupPartner.
     */
    data: XOR<PartnerGroupPartnerCreateInput, PartnerGroupPartnerUncheckedCreateInput>
  }

  /**
   * PartnerGroupPartner createMany
   */
  export type PartnerGroupPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerGroupPartners.
     */
    data: PartnerGroupPartnerCreateManyInput | PartnerGroupPartnerCreateManyInput[]
  }

  /**
   * PartnerGroupPartner createManyAndReturn
   */
  export type PartnerGroupPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerGroupPartners.
     */
    data: PartnerGroupPartnerCreateManyInput | PartnerGroupPartnerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerGroupPartner update
   */
  export type PartnerGroupPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerGroupPartner.
     */
    data: XOR<PartnerGroupPartnerUpdateInput, PartnerGroupPartnerUncheckedUpdateInput>
    /**
     * Choose, which PartnerGroupPartner to update.
     */
    where: PartnerGroupPartnerWhereUniqueInput
  }

  /**
   * PartnerGroupPartner updateMany
   */
  export type PartnerGroupPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerGroupPartners.
     */
    data: XOR<PartnerGroupPartnerUpdateManyMutationInput, PartnerGroupPartnerUncheckedUpdateManyInput>
    /**
     * Filter which PartnerGroupPartners to update
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * Limit how many PartnerGroupPartners to update.
     */
    limit?: number
  }

  /**
   * PartnerGroupPartner updateManyAndReturn
   */
  export type PartnerGroupPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * The data used to update PartnerGroupPartners.
     */
    data: XOR<PartnerGroupPartnerUpdateManyMutationInput, PartnerGroupPartnerUncheckedUpdateManyInput>
    /**
     * Filter which PartnerGroupPartners to update
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * Limit how many PartnerGroupPartners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerGroupPartner upsert
   */
  export type PartnerGroupPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerGroupPartner to update in case it exists.
     */
    where: PartnerGroupPartnerWhereUniqueInput
    /**
     * In case the PartnerGroupPartner found by the `where` argument doesn't exist, create a new PartnerGroupPartner with this data.
     */
    create: XOR<PartnerGroupPartnerCreateInput, PartnerGroupPartnerUncheckedCreateInput>
    /**
     * In case the PartnerGroupPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerGroupPartnerUpdateInput, PartnerGroupPartnerUncheckedUpdateInput>
  }

  /**
   * PartnerGroupPartner delete
   */
  export type PartnerGroupPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
    /**
     * Filter which PartnerGroupPartner to delete.
     */
    where: PartnerGroupPartnerWhereUniqueInput
  }

  /**
   * PartnerGroupPartner deleteMany
   */
  export type PartnerGroupPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerGroupPartners to delete
     */
    where?: PartnerGroupPartnerWhereInput
    /**
     * Limit how many PartnerGroupPartners to delete.
     */
    limit?: number
  }

  /**
   * PartnerGroupPartner without action
   */
  export type PartnerGroupPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerGroupPartner
     */
    select?: PartnerGroupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerGroupPartner
     */
    omit?: PartnerGroupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerGroupPartnerInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValues: string | null
    newValues: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValues: string | null
    newValues: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    userId: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    oldValues: string | null
    newValues: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "oldValues" | "newValues" | "userId" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      oldValues: string | null
      newValues: string | null
      userId: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'String'>
    readonly newValues: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    key: string
    value: string
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model KeyVal
   */

  export type AggregateKeyVal = {
    _count: KeyValCountAggregateOutputType | null
    _min: KeyValMinAggregateOutputType | null
    _max: KeyValMaxAggregateOutputType | null
  }

  export type KeyValMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type KeyValMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type KeyValCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type KeyValMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type KeyValMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type KeyValCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type KeyValAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyVal to aggregate.
     */
    where?: KeyValWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyVals to fetch.
     */
    orderBy?: KeyValOrderByWithRelationInput | KeyValOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyValWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyVals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyVals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyVals
    **/
    _count?: true | KeyValCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyValMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyValMaxAggregateInputType
  }

  export type GetKeyValAggregateType<T extends KeyValAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyVal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyVal[P]>
      : GetScalarType<T[P], AggregateKeyVal[P]>
  }




  export type KeyValGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyValWhereInput
    orderBy?: KeyValOrderByWithAggregationInput | KeyValOrderByWithAggregationInput[]
    by: KeyValScalarFieldEnum[] | KeyValScalarFieldEnum
    having?: KeyValScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyValCountAggregateInputType | true
    _min?: KeyValMinAggregateInputType
    _max?: KeyValMaxAggregateInputType
  }

  export type KeyValGroupByOutputType = {
    id: string
    key: string
    value: string
    _count: KeyValCountAggregateOutputType | null
    _min: KeyValMinAggregateOutputType | null
    _max: KeyValMaxAggregateOutputType | null
  }

  type GetKeyValGroupByPayload<T extends KeyValGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyValGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyValGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyValGroupByOutputType[P]>
            : GetScalarType<T[P], KeyValGroupByOutputType[P]>
        }
      >
    >


  export type KeyValSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["keyVal"]>

  export type KeyValSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["keyVal"]>

  export type KeyValSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["keyVal"]>

  export type KeyValSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type KeyValOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["keyVal"]>

  export type $KeyValPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeyVal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
    }, ExtArgs["result"]["keyVal"]>
    composites: {}
  }

  type KeyValGetPayload<S extends boolean | null | undefined | KeyValDefaultArgs> = $Result.GetResult<Prisma.$KeyValPayload, S>

  type KeyValCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeyValFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeyValCountAggregateInputType | true
    }

  export interface KeyValDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyVal'], meta: { name: 'KeyVal' } }
    /**
     * Find zero or one KeyVal that matches the filter.
     * @param {KeyValFindUniqueArgs} args - Arguments to find a KeyVal
     * @example
     * // Get one KeyVal
     * const keyVal = await prisma.keyVal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyValFindUniqueArgs>(args: SelectSubset<T, KeyValFindUniqueArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeyVal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyValFindUniqueOrThrowArgs} args - Arguments to find a KeyVal
     * @example
     * // Get one KeyVal
     * const keyVal = await prisma.keyVal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyValFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyValFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyVal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValFindFirstArgs} args - Arguments to find a KeyVal
     * @example
     * // Get one KeyVal
     * const keyVal = await prisma.keyVal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyValFindFirstArgs>(args?: SelectSubset<T, KeyValFindFirstArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeyVal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValFindFirstOrThrowArgs} args - Arguments to find a KeyVal
     * @example
     * // Get one KeyVal
     * const keyVal = await prisma.keyVal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyValFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyValFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeyVals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyVals
     * const keyVals = await prisma.keyVal.findMany()
     * 
     * // Get first 10 KeyVals
     * const keyVals = await prisma.keyVal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyValWithIdOnly = await prisma.keyVal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyValFindManyArgs>(args?: SelectSubset<T, KeyValFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeyVal.
     * @param {KeyValCreateArgs} args - Arguments to create a KeyVal.
     * @example
     * // Create one KeyVal
     * const KeyVal = await prisma.keyVal.create({
     *   data: {
     *     // ... data to create a KeyVal
     *   }
     * })
     * 
     */
    create<T extends KeyValCreateArgs>(args: SelectSubset<T, KeyValCreateArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeyVals.
     * @param {KeyValCreateManyArgs} args - Arguments to create many KeyVals.
     * @example
     * // Create many KeyVals
     * const keyVal = await prisma.keyVal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyValCreateManyArgs>(args?: SelectSubset<T, KeyValCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeyVals and returns the data saved in the database.
     * @param {KeyValCreateManyAndReturnArgs} args - Arguments to create many KeyVals.
     * @example
     * // Create many KeyVals
     * const keyVal = await prisma.keyVal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeyVals and only return the `id`
     * const keyValWithIdOnly = await prisma.keyVal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeyValCreateManyAndReturnArgs>(args?: SelectSubset<T, KeyValCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeyVal.
     * @param {KeyValDeleteArgs} args - Arguments to delete one KeyVal.
     * @example
     * // Delete one KeyVal
     * const KeyVal = await prisma.keyVal.delete({
     *   where: {
     *     // ... filter to delete one KeyVal
     *   }
     * })
     * 
     */
    delete<T extends KeyValDeleteArgs>(args: SelectSubset<T, KeyValDeleteArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeyVal.
     * @param {KeyValUpdateArgs} args - Arguments to update one KeyVal.
     * @example
     * // Update one KeyVal
     * const keyVal = await prisma.keyVal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyValUpdateArgs>(args: SelectSubset<T, KeyValUpdateArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeyVals.
     * @param {KeyValDeleteManyArgs} args - Arguments to filter KeyVals to delete.
     * @example
     * // Delete a few KeyVals
     * const { count } = await prisma.keyVal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyValDeleteManyArgs>(args?: SelectSubset<T, KeyValDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyVals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyVals
     * const keyVal = await prisma.keyVal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyValUpdateManyArgs>(args: SelectSubset<T, KeyValUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyVals and returns the data updated in the database.
     * @param {KeyValUpdateManyAndReturnArgs} args - Arguments to update many KeyVals.
     * @example
     * // Update many KeyVals
     * const keyVal = await prisma.keyVal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeyVals and only return the `id`
     * const keyValWithIdOnly = await prisma.keyVal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeyValUpdateManyAndReturnArgs>(args: SelectSubset<T, KeyValUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeyVal.
     * @param {KeyValUpsertArgs} args - Arguments to update or create a KeyVal.
     * @example
     * // Update or create a KeyVal
     * const keyVal = await prisma.keyVal.upsert({
     *   create: {
     *     // ... data to create a KeyVal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyVal we want to update
     *   }
     * })
     */
    upsert<T extends KeyValUpsertArgs>(args: SelectSubset<T, KeyValUpsertArgs<ExtArgs>>): Prisma__KeyValClient<$Result.GetResult<Prisma.$KeyValPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeyVals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValCountArgs} args - Arguments to filter KeyVals to count.
     * @example
     * // Count the number of KeyVals
     * const count = await prisma.keyVal.count({
     *   where: {
     *     // ... the filter for the KeyVals we want to count
     *   }
     * })
    **/
    count<T extends KeyValCountArgs>(
      args?: Subset<T, KeyValCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyValCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyVal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyValAggregateArgs>(args: Subset<T, KeyValAggregateArgs>): Prisma.PrismaPromise<GetKeyValAggregateType<T>>

    /**
     * Group by KeyVal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyValGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyValGroupByArgs['orderBy'] }
        : { orderBy?: KeyValGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyValGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyValGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyVal model
   */
  readonly fields: KeyValFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyVal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyValClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeyVal model
   */
  interface KeyValFieldRefs {
    readonly id: FieldRef<"KeyVal", 'String'>
    readonly key: FieldRef<"KeyVal", 'String'>
    readonly value: FieldRef<"KeyVal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KeyVal findUnique
   */
  export type KeyValFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter, which KeyVal to fetch.
     */
    where: KeyValWhereUniqueInput
  }

  /**
   * KeyVal findUniqueOrThrow
   */
  export type KeyValFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter, which KeyVal to fetch.
     */
    where: KeyValWhereUniqueInput
  }

  /**
   * KeyVal findFirst
   */
  export type KeyValFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter, which KeyVal to fetch.
     */
    where?: KeyValWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyVals to fetch.
     */
    orderBy?: KeyValOrderByWithRelationInput | KeyValOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyVals.
     */
    cursor?: KeyValWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyVals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyVals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyVals.
     */
    distinct?: KeyValScalarFieldEnum | KeyValScalarFieldEnum[]
  }

  /**
   * KeyVal findFirstOrThrow
   */
  export type KeyValFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter, which KeyVal to fetch.
     */
    where?: KeyValWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyVals to fetch.
     */
    orderBy?: KeyValOrderByWithRelationInput | KeyValOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyVals.
     */
    cursor?: KeyValWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyVals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyVals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyVals.
     */
    distinct?: KeyValScalarFieldEnum | KeyValScalarFieldEnum[]
  }

  /**
   * KeyVal findMany
   */
  export type KeyValFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter, which KeyVals to fetch.
     */
    where?: KeyValWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyVals to fetch.
     */
    orderBy?: KeyValOrderByWithRelationInput | KeyValOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyVals.
     */
    cursor?: KeyValWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyVals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyVals.
     */
    skip?: number
    distinct?: KeyValScalarFieldEnum | KeyValScalarFieldEnum[]
  }

  /**
   * KeyVal create
   */
  export type KeyValCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * The data needed to create a KeyVal.
     */
    data: XOR<KeyValCreateInput, KeyValUncheckedCreateInput>
  }

  /**
   * KeyVal createMany
   */
  export type KeyValCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeyVals.
     */
    data: KeyValCreateManyInput | KeyValCreateManyInput[]
  }

  /**
   * KeyVal createManyAndReturn
   */
  export type KeyValCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * The data used to create many KeyVals.
     */
    data: KeyValCreateManyInput | KeyValCreateManyInput[]
  }

  /**
   * KeyVal update
   */
  export type KeyValUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * The data needed to update a KeyVal.
     */
    data: XOR<KeyValUpdateInput, KeyValUncheckedUpdateInput>
    /**
     * Choose, which KeyVal to update.
     */
    where: KeyValWhereUniqueInput
  }

  /**
   * KeyVal updateMany
   */
  export type KeyValUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeyVals.
     */
    data: XOR<KeyValUpdateManyMutationInput, KeyValUncheckedUpdateManyInput>
    /**
     * Filter which KeyVals to update
     */
    where?: KeyValWhereInput
    /**
     * Limit how many KeyVals to update.
     */
    limit?: number
  }

  /**
   * KeyVal updateManyAndReturn
   */
  export type KeyValUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * The data used to update KeyVals.
     */
    data: XOR<KeyValUpdateManyMutationInput, KeyValUncheckedUpdateManyInput>
    /**
     * Filter which KeyVals to update
     */
    where?: KeyValWhereInput
    /**
     * Limit how many KeyVals to update.
     */
    limit?: number
  }

  /**
   * KeyVal upsert
   */
  export type KeyValUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * The filter to search for the KeyVal to update in case it exists.
     */
    where: KeyValWhereUniqueInput
    /**
     * In case the KeyVal found by the `where` argument doesn't exist, create a new KeyVal with this data.
     */
    create: XOR<KeyValCreateInput, KeyValUncheckedCreateInput>
    /**
     * In case the KeyVal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyValUpdateInput, KeyValUncheckedUpdateInput>
  }

  /**
   * KeyVal delete
   */
  export type KeyValDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
    /**
     * Filter which KeyVal to delete.
     */
    where: KeyValWhereUniqueInput
  }

  /**
   * KeyVal deleteMany
   */
  export type KeyValDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyVals to delete
     */
    where?: KeyValWhereInput
    /**
     * Limit how many KeyVals to delete.
     */
    limit?: number
  }

  /**
   * KeyVal without action
   */
  export type KeyValDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyVal
     */
    select?: KeyValSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeyVal
     */
    omit?: KeyValOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    email: string | null
    name: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    email: string | null
    name: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    name: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    email: string | null
    name: string | null
    role: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "email" | "name" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      email: string | null
      name: string | null
      role: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    category: string | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    data: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    category: string | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
    data: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    category: number
    acknowledged: number
    acknowledgedAt: number
    acknowledgedBy: number
    createdAt: number
    expiresAt: number
    data: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    category?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
    expiresAt?: true
    data?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    category?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
    expiresAt?: true
    data?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    category?: true
    acknowledged?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    createdAt?: true
    expiresAt?: true
    data?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    message: string
    category: string
    acknowledged: boolean
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    createdAt: Date
    expiresAt: Date | null
    data: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    category?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    data?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    category?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    data?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    category?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    data?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    category?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    data?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "category" | "acknowledged" | "acknowledgedAt" | "acknowledgedBy" | "createdAt" | "expiresAt" | "data", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      message: string
      category: string
      acknowledged: boolean
      acknowledgedAt: Date | null
      acknowledgedBy: string | null
      createdAt: Date
      expiresAt: Date | null
      data: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly acknowledged: FieldRef<"Notification", 'Boolean'>
    readonly acknowledgedAt: FieldRef<"Notification", 'DateTime'>
    readonly acknowledgedBy: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly data: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    nationalId: 'nationalId',
    address: 'address',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    unitType: 'unitType',
    area: 'area',
    floor: 'floor',
    building: 'building',
    totalPrice: 'totalPrice',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const UnitPartnerScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    partnerId: 'partnerId',
    percentage: 'percentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UnitPartnerScalarFieldEnum = (typeof UnitPartnerScalarFieldEnum)[keyof typeof UnitPartnerScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    customerId: 'customerId',
    start: 'start',
    totalPrice: 'totalPrice',
    discountAmount: 'discountAmount',
    brokerName: 'brokerName',
    brokerPercent: 'brokerPercent',
    brokerAmount: 'brokerAmount',
    commissionSafeId: 'commissionSafeId',
    downPaymentSafeId: 'downPaymentSafeId',
    maintenanceDeposit: 'maintenanceDeposit',
    installmentType: 'installmentType',
    installmentCount: 'installmentCount',
    extraAnnual: 'extraAnnual',
    annualPaymentValue: 'annualPaymentValue',
    downPayment: 'downPayment',
    paymentType: 'paymentType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const InstallmentScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type InstallmentScalarFieldEnum = (typeof InstallmentScalarFieldEnum)[keyof typeof InstallmentScalarFieldEnum]


  export const PartnerDebtScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PartnerDebtScalarFieldEnum = (typeof PartnerDebtScalarFieldEnum)[keyof typeof PartnerDebtScalarFieldEnum]


  export const SafeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SafeScalarFieldEnum = (typeof SafeScalarFieldEnum)[keyof typeof SafeScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    fromSafeId: 'fromSafeId',
    toSafeId: 'toSafeId',
    amount: 'amount',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    type: 'type',
    date: 'date',
    amount: 'amount',
    safeId: 'safeId',
    description: 'description',
    payer: 'payer',
    beneficiary: 'beneficiary',
    linkedRef: 'linkedRef',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const BrokerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BrokerScalarFieldEnum = (typeof BrokerScalarFieldEnum)[keyof typeof BrokerScalarFieldEnum]


  export const BrokerDueScalarFieldEnum: {
    id: 'id',
    brokerId: 'brokerId',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BrokerDueScalarFieldEnum = (typeof BrokerDueScalarFieldEnum)[keyof typeof BrokerDueScalarFieldEnum]


  export const PartnerGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PartnerGroupScalarFieldEnum = (typeof PartnerGroupScalarFieldEnum)[keyof typeof PartnerGroupScalarFieldEnum]


  export const PartnerGroupPartnerScalarFieldEnum: {
    id: 'id',
    partnerGroupId: 'partnerGroupId',
    partnerId: 'partnerId',
    percentage: 'percentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PartnerGroupPartnerScalarFieldEnum = (typeof PartnerGroupPartnerScalarFieldEnum)[keyof typeof PartnerGroupPartnerScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    userId: 'userId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const KeyValScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type KeyValScalarFieldEnum = (typeof KeyValScalarFieldEnum)[keyof typeof KeyValScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    category: 'category',
    acknowledged: 'acknowledged',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgedBy: 'acknowledgedBy',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    data: 'data'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    nationalId?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    status?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    contracts?: ContractListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    nationalId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    contracts?: ContractOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    nationalId?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    status?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    contracts?: ContractListRelationFilter
  }, "id" | "phone" | "nationalId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    nationalId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    nationalId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    status?: StringWithAggregatesFilter<"Customer"> | string
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringNullableFilter<"Unit"> | string | null
    unitType?: StringFilter<"Unit"> | string
    area?: StringNullableFilter<"Unit"> | string | null
    floor?: StringNullableFilter<"Unit"> | string | null
    building?: StringNullableFilter<"Unit"> | string | null
    totalPrice?: FloatFilter<"Unit"> | number
    status?: StringFilter<"Unit"> | string
    notes?: StringNullableFilter<"Unit"> | string | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    contracts?: ContractListRelationFilter
    installments?: InstallmentListRelationFilter
    vouchers?: VoucherListRelationFilter
    unitPartners?: UnitPartnerListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    unitType?: SortOrder
    area?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    installments?: InstallmentOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    unitPartners?: UnitPartnerOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringNullableFilter<"Unit"> | string | null
    unitType?: StringFilter<"Unit"> | string
    area?: StringNullableFilter<"Unit"> | string | null
    floor?: StringNullableFilter<"Unit"> | string | null
    building?: StringNullableFilter<"Unit"> | string | null
    totalPrice?: FloatFilter<"Unit"> | number
    status?: StringFilter<"Unit"> | string
    notes?: StringNullableFilter<"Unit"> | string | null
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    contracts?: ContractListRelationFilter
    installments?: InstallmentListRelationFilter
    vouchers?: VoucherListRelationFilter
    unitPartners?: UnitPartnerListRelationFilter
  }, "id" | "code">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    unitType?: SortOrder
    area?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    code?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    unitType?: StringWithAggregatesFilter<"Unit"> | string
    area?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    floor?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    building?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    totalPrice?: FloatWithAggregatesFilter<"Unit"> | number
    status?: StringWithAggregatesFilter<"Unit"> | string
    notes?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    phone?: StringNullableFilter<"Partner"> | string | null
    notes?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Partner"> | Date | string | null
    unitPartners?: UnitPartnerListRelationFilter
    partnerDebts?: PartnerDebtListRelationFilter
    partnerGroupPartners?: PartnerGroupPartnerListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    unitPartners?: UnitPartnerOrderByRelationAggregateInput
    partnerDebts?: PartnerDebtOrderByRelationAggregateInput
    partnerGroupPartners?: PartnerGroupPartnerOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    name?: StringFilter<"Partner"> | string
    phone?: StringNullableFilter<"Partner"> | string | null
    notes?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Partner"> | Date | string | null
    unitPartners?: UnitPartnerListRelationFilter
    partnerDebts?: PartnerDebtListRelationFilter
    partnerGroupPartners?: PartnerGroupPartnerListRelationFilter
  }, "id">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    phone?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Partner"> | Date | string | null
  }

  export type UnitPartnerWhereInput = {
    AND?: UnitPartnerWhereInput | UnitPartnerWhereInput[]
    OR?: UnitPartnerWhereInput[]
    NOT?: UnitPartnerWhereInput | UnitPartnerWhereInput[]
    id?: StringFilter<"UnitPartner"> | string
    unitId?: StringFilter<"UnitPartner"> | string
    partnerId?: StringFilter<"UnitPartner"> | string
    percentage?: FloatFilter<"UnitPartner"> | number
    createdAt?: DateTimeFilter<"UnitPartner"> | Date | string
    updatedAt?: DateTimeFilter<"UnitPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UnitPartner"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type UnitPartnerOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
  }

  export type UnitPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitId_partnerId?: UnitPartnerUnitIdPartnerIdCompoundUniqueInput
    AND?: UnitPartnerWhereInput | UnitPartnerWhereInput[]
    OR?: UnitPartnerWhereInput[]
    NOT?: UnitPartnerWhereInput | UnitPartnerWhereInput[]
    unitId?: StringFilter<"UnitPartner"> | string
    partnerId?: StringFilter<"UnitPartner"> | string
    percentage?: FloatFilter<"UnitPartner"> | number
    createdAt?: DateTimeFilter<"UnitPartner"> | Date | string
    updatedAt?: DateTimeFilter<"UnitPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UnitPartner"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id" | "unitId_partnerId">

  export type UnitPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UnitPartnerCountOrderByAggregateInput
    _avg?: UnitPartnerAvgOrderByAggregateInput
    _max?: UnitPartnerMaxOrderByAggregateInput
    _min?: UnitPartnerMinOrderByAggregateInput
    _sum?: UnitPartnerSumOrderByAggregateInput
  }

  export type UnitPartnerScalarWhereWithAggregatesInput = {
    AND?: UnitPartnerScalarWhereWithAggregatesInput | UnitPartnerScalarWhereWithAggregatesInput[]
    OR?: UnitPartnerScalarWhereWithAggregatesInput[]
    NOT?: UnitPartnerScalarWhereWithAggregatesInput | UnitPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitPartner"> | string
    unitId?: StringWithAggregatesFilter<"UnitPartner"> | string
    partnerId?: StringWithAggregatesFilter<"UnitPartner"> | string
    percentage?: FloatWithAggregatesFilter<"UnitPartner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnitPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitPartner"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UnitPartner"> | Date | string | null
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    unitId?: StringFilter<"Contract"> | string
    customerId?: StringFilter<"Contract"> | string
    start?: DateTimeFilter<"Contract"> | Date | string
    totalPrice?: FloatFilter<"Contract"> | number
    discountAmount?: FloatFilter<"Contract"> | number
    brokerName?: StringNullableFilter<"Contract"> | string | null
    brokerPercent?: FloatFilter<"Contract"> | number
    brokerAmount?: FloatFilter<"Contract"> | number
    commissionSafeId?: StringNullableFilter<"Contract"> | string | null
    downPaymentSafeId?: StringNullableFilter<"Contract"> | string | null
    maintenanceDeposit?: FloatFilter<"Contract"> | number
    installmentType?: StringFilter<"Contract"> | string
    installmentCount?: IntFilter<"Contract"> | number
    extraAnnual?: IntFilter<"Contract"> | number
    annualPaymentValue?: FloatFilter<"Contract"> | number
    downPayment?: FloatFilter<"Contract"> | number
    paymentType?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    customerId?: SortOrder
    start?: SortOrder
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerName?: SortOrderInput | SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    commissionSafeId?: SortOrderInput | SortOrder
    downPaymentSafeId?: SortOrderInput | SortOrder
    maintenanceDeposit?: SortOrder
    installmentType?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    unitId?: StringFilter<"Contract"> | string
    customerId?: StringFilter<"Contract"> | string
    start?: DateTimeFilter<"Contract"> | Date | string
    totalPrice?: FloatFilter<"Contract"> | number
    discountAmount?: FloatFilter<"Contract"> | number
    brokerName?: StringNullableFilter<"Contract"> | string | null
    brokerPercent?: FloatFilter<"Contract"> | number
    brokerAmount?: FloatFilter<"Contract"> | number
    commissionSafeId?: StringNullableFilter<"Contract"> | string | null
    downPaymentSafeId?: StringNullableFilter<"Contract"> | string | null
    maintenanceDeposit?: FloatFilter<"Contract"> | number
    installmentType?: StringFilter<"Contract"> | string
    installmentCount?: IntFilter<"Contract"> | number
    extraAnnual?: IntFilter<"Contract"> | number
    annualPaymentValue?: FloatFilter<"Contract"> | number
    downPayment?: FloatFilter<"Contract"> | number
    paymentType?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    customerId?: SortOrder
    start?: SortOrder
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerName?: SortOrderInput | SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    commissionSafeId?: SortOrderInput | SortOrder
    downPaymentSafeId?: SortOrderInput | SortOrder
    maintenanceDeposit?: SortOrder
    installmentType?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    unitId?: StringWithAggregatesFilter<"Contract"> | string
    customerId?: StringWithAggregatesFilter<"Contract"> | string
    start?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    totalPrice?: FloatWithAggregatesFilter<"Contract"> | number
    discountAmount?: FloatWithAggregatesFilter<"Contract"> | number
    brokerName?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    brokerPercent?: FloatWithAggregatesFilter<"Contract"> | number
    brokerAmount?: FloatWithAggregatesFilter<"Contract"> | number
    commissionSafeId?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    downPaymentSafeId?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    maintenanceDeposit?: FloatWithAggregatesFilter<"Contract"> | number
    installmentType?: StringWithAggregatesFilter<"Contract"> | string
    installmentCount?: IntWithAggregatesFilter<"Contract"> | number
    extraAnnual?: IntWithAggregatesFilter<"Contract"> | number
    annualPaymentValue?: FloatWithAggregatesFilter<"Contract"> | number
    downPayment?: FloatWithAggregatesFilter<"Contract"> | number
    paymentType?: StringWithAggregatesFilter<"Contract"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
  }

  export type InstallmentWhereInput = {
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    id?: StringFilter<"Installment"> | string
    unitId?: StringFilter<"Installment"> | string
    amount?: FloatFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    notes?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type InstallmentOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type InstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    unitId?: StringFilter<"Installment"> | string
    amount?: FloatFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    notes?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type InstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: InstallmentCountOrderByAggregateInput
    _avg?: InstallmentAvgOrderByAggregateInput
    _max?: InstallmentMaxOrderByAggregateInput
    _min?: InstallmentMinOrderByAggregateInput
    _sum?: InstallmentSumOrderByAggregateInput
  }

  export type InstallmentScalarWhereWithAggregatesInput = {
    AND?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    OR?: InstallmentScalarWhereWithAggregatesInput[]
    NOT?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Installment"> | string
    unitId?: StringWithAggregatesFilter<"Installment"> | string
    amount?: FloatWithAggregatesFilter<"Installment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    status?: StringWithAggregatesFilter<"Installment"> | string
    notes?: StringNullableWithAggregatesFilter<"Installment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Installment"> | Date | string | null
  }

  export type PartnerDebtWhereInput = {
    AND?: PartnerDebtWhereInput | PartnerDebtWhereInput[]
    OR?: PartnerDebtWhereInput[]
    NOT?: PartnerDebtWhereInput | PartnerDebtWhereInput[]
    id?: StringFilter<"PartnerDebt"> | string
    partnerId?: StringFilter<"PartnerDebt"> | string
    amount?: FloatFilter<"PartnerDebt"> | number
    dueDate?: DateTimeFilter<"PartnerDebt"> | Date | string
    status?: StringFilter<"PartnerDebt"> | string
    notes?: StringNullableFilter<"PartnerDebt"> | string | null
    createdAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerDebt"> | Date | string | null
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type PartnerDebtOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerDebtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerDebtWhereInput | PartnerDebtWhereInput[]
    OR?: PartnerDebtWhereInput[]
    NOT?: PartnerDebtWhereInput | PartnerDebtWhereInput[]
    partnerId?: StringFilter<"PartnerDebt"> | string
    amount?: FloatFilter<"PartnerDebt"> | number
    dueDate?: DateTimeFilter<"PartnerDebt"> | Date | string
    status?: StringFilter<"PartnerDebt"> | string
    notes?: StringNullableFilter<"PartnerDebt"> | string | null
    createdAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerDebt"> | Date | string | null
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id">

  export type PartnerDebtOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PartnerDebtCountOrderByAggregateInput
    _avg?: PartnerDebtAvgOrderByAggregateInput
    _max?: PartnerDebtMaxOrderByAggregateInput
    _min?: PartnerDebtMinOrderByAggregateInput
    _sum?: PartnerDebtSumOrderByAggregateInput
  }

  export type PartnerDebtScalarWhereWithAggregatesInput = {
    AND?: PartnerDebtScalarWhereWithAggregatesInput | PartnerDebtScalarWhereWithAggregatesInput[]
    OR?: PartnerDebtScalarWhereWithAggregatesInput[]
    NOT?: PartnerDebtScalarWhereWithAggregatesInput | PartnerDebtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerDebt"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerDebt"> | string
    amount?: FloatWithAggregatesFilter<"PartnerDebt"> | number
    dueDate?: DateTimeWithAggregatesFilter<"PartnerDebt"> | Date | string
    status?: StringWithAggregatesFilter<"PartnerDebt"> | string
    notes?: StringNullableWithAggregatesFilter<"PartnerDebt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PartnerDebt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerDebt"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PartnerDebt"> | Date | string | null
  }

  export type SafeWhereInput = {
    AND?: SafeWhereInput | SafeWhereInput[]
    OR?: SafeWhereInput[]
    NOT?: SafeWhereInput | SafeWhereInput[]
    id?: StringFilter<"Safe"> | string
    name?: StringFilter<"Safe"> | string
    balance?: FloatFilter<"Safe"> | number
    createdAt?: DateTimeFilter<"Safe"> | Date | string
    updatedAt?: DateTimeFilter<"Safe"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Safe"> | Date | string | null
    vouchers?: VoucherListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
  }

  export type SafeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    vouchers?: VoucherOrderByRelationAggregateInput
    transfersFrom?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
  }

  export type SafeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SafeWhereInput | SafeWhereInput[]
    OR?: SafeWhereInput[]
    NOT?: SafeWhereInput | SafeWhereInput[]
    balance?: FloatFilter<"Safe"> | number
    createdAt?: DateTimeFilter<"Safe"> | Date | string
    updatedAt?: DateTimeFilter<"Safe"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Safe"> | Date | string | null
    vouchers?: VoucherListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
  }, "id" | "name">

  export type SafeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SafeCountOrderByAggregateInput
    _avg?: SafeAvgOrderByAggregateInput
    _max?: SafeMaxOrderByAggregateInput
    _min?: SafeMinOrderByAggregateInput
    _sum?: SafeSumOrderByAggregateInput
  }

  export type SafeScalarWhereWithAggregatesInput = {
    AND?: SafeScalarWhereWithAggregatesInput | SafeScalarWhereWithAggregatesInput[]
    OR?: SafeScalarWhereWithAggregatesInput[]
    NOT?: SafeScalarWhereWithAggregatesInput | SafeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Safe"> | string
    name?: StringWithAggregatesFilter<"Safe"> | string
    balance?: FloatWithAggregatesFilter<"Safe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Safe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Safe"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Safe"> | Date | string | null
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    fromSafeId?: StringFilter<"Transfer"> | string
    toSafeId?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    description?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    fromSafe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
    toSafe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    fromSafeId?: SortOrder
    toSafeId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    fromSafe?: SafeOrderByWithRelationInput
    toSafe?: SafeOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    fromSafeId?: StringFilter<"Transfer"> | string
    toSafeId?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    description?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    fromSafe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
    toSafe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
  }, "id">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    fromSafeId?: SortOrder
    toSafeId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    fromSafeId?: StringWithAggregatesFilter<"Transfer"> | string
    toSafeId?: StringWithAggregatesFilter<"Transfer"> | string
    amount?: FloatWithAggregatesFilter<"Transfer"> | number
    description?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    type?: StringFilter<"Voucher"> | string
    date?: DateTimeFilter<"Voucher"> | Date | string
    amount?: FloatFilter<"Voucher"> | number
    safeId?: StringFilter<"Voucher"> | string
    description?: StringFilter<"Voucher"> | string
    payer?: StringNullableFilter<"Voucher"> | string | null
    beneficiary?: StringNullableFilter<"Voucher"> | string | null
    linkedRef?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    safe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    safeId?: SortOrder
    description?: SortOrder
    payer?: SortOrderInput | SortOrder
    beneficiary?: SortOrderInput | SortOrder
    linkedRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    safe?: SafeOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    type?: StringFilter<"Voucher"> | string
    date?: DateTimeFilter<"Voucher"> | Date | string
    amount?: FloatFilter<"Voucher"> | number
    safeId?: StringFilter<"Voucher"> | string
    description?: StringFilter<"Voucher"> | string
    payer?: StringNullableFilter<"Voucher"> | string | null
    beneficiary?: StringNullableFilter<"Voucher"> | string | null
    linkedRef?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    safe?: XOR<SafeScalarRelationFilter, SafeWhereInput>
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    safeId?: SortOrder
    description?: SortOrder
    payer?: SortOrderInput | SortOrder
    beneficiary?: SortOrderInput | SortOrder
    linkedRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    type?: StringWithAggregatesFilter<"Voucher"> | string
    date?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    amount?: FloatWithAggregatesFilter<"Voucher"> | number
    safeId?: StringWithAggregatesFilter<"Voucher"> | string
    description?: StringWithAggregatesFilter<"Voucher"> | string
    payer?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    beneficiary?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    linkedRef?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
  }

  export type BrokerWhereInput = {
    AND?: BrokerWhereInput | BrokerWhereInput[]
    OR?: BrokerWhereInput[]
    NOT?: BrokerWhereInput | BrokerWhereInput[]
    id?: StringFilter<"Broker"> | string
    name?: StringFilter<"Broker"> | string
    phone?: StringNullableFilter<"Broker"> | string | null
    notes?: StringNullableFilter<"Broker"> | string | null
    createdAt?: DateTimeFilter<"Broker"> | Date | string
    updatedAt?: DateTimeFilter<"Broker"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Broker"> | Date | string | null
    brokerDues?: BrokerDueListRelationFilter
  }

  export type BrokerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    brokerDues?: BrokerDueOrderByRelationAggregateInput
  }

  export type BrokerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BrokerWhereInput | BrokerWhereInput[]
    OR?: BrokerWhereInput[]
    NOT?: BrokerWhereInput | BrokerWhereInput[]
    phone?: StringNullableFilter<"Broker"> | string | null
    notes?: StringNullableFilter<"Broker"> | string | null
    createdAt?: DateTimeFilter<"Broker"> | Date | string
    updatedAt?: DateTimeFilter<"Broker"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Broker"> | Date | string | null
    brokerDues?: BrokerDueListRelationFilter
  }, "id" | "name">

  export type BrokerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BrokerCountOrderByAggregateInput
    _max?: BrokerMaxOrderByAggregateInput
    _min?: BrokerMinOrderByAggregateInput
  }

  export type BrokerScalarWhereWithAggregatesInput = {
    AND?: BrokerScalarWhereWithAggregatesInput | BrokerScalarWhereWithAggregatesInput[]
    OR?: BrokerScalarWhereWithAggregatesInput[]
    NOT?: BrokerScalarWhereWithAggregatesInput | BrokerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Broker"> | string
    name?: StringWithAggregatesFilter<"Broker"> | string
    phone?: StringNullableWithAggregatesFilter<"Broker"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Broker"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Broker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Broker"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Broker"> | Date | string | null
  }

  export type BrokerDueWhereInput = {
    AND?: BrokerDueWhereInput | BrokerDueWhereInput[]
    OR?: BrokerDueWhereInput[]
    NOT?: BrokerDueWhereInput | BrokerDueWhereInput[]
    id?: StringFilter<"BrokerDue"> | string
    brokerId?: StringFilter<"BrokerDue"> | string
    amount?: FloatFilter<"BrokerDue"> | number
    dueDate?: DateTimeFilter<"BrokerDue"> | Date | string
    status?: StringFilter<"BrokerDue"> | string
    notes?: StringNullableFilter<"BrokerDue"> | string | null
    createdAt?: DateTimeFilter<"BrokerDue"> | Date | string
    updatedAt?: DateTimeFilter<"BrokerDue"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BrokerDue"> | Date | string | null
    broker?: XOR<BrokerScalarRelationFilter, BrokerWhereInput>
  }

  export type BrokerDueOrderByWithRelationInput = {
    id?: SortOrder
    brokerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    broker?: BrokerOrderByWithRelationInput
  }

  export type BrokerDueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BrokerDueWhereInput | BrokerDueWhereInput[]
    OR?: BrokerDueWhereInput[]
    NOT?: BrokerDueWhereInput | BrokerDueWhereInput[]
    brokerId?: StringFilter<"BrokerDue"> | string
    amount?: FloatFilter<"BrokerDue"> | number
    dueDate?: DateTimeFilter<"BrokerDue"> | Date | string
    status?: StringFilter<"BrokerDue"> | string
    notes?: StringNullableFilter<"BrokerDue"> | string | null
    createdAt?: DateTimeFilter<"BrokerDue"> | Date | string
    updatedAt?: DateTimeFilter<"BrokerDue"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BrokerDue"> | Date | string | null
    broker?: XOR<BrokerScalarRelationFilter, BrokerWhereInput>
  }, "id">

  export type BrokerDueOrderByWithAggregationInput = {
    id?: SortOrder
    brokerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BrokerDueCountOrderByAggregateInput
    _avg?: BrokerDueAvgOrderByAggregateInput
    _max?: BrokerDueMaxOrderByAggregateInput
    _min?: BrokerDueMinOrderByAggregateInput
    _sum?: BrokerDueSumOrderByAggregateInput
  }

  export type BrokerDueScalarWhereWithAggregatesInput = {
    AND?: BrokerDueScalarWhereWithAggregatesInput | BrokerDueScalarWhereWithAggregatesInput[]
    OR?: BrokerDueScalarWhereWithAggregatesInput[]
    NOT?: BrokerDueScalarWhereWithAggregatesInput | BrokerDueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BrokerDue"> | string
    brokerId?: StringWithAggregatesFilter<"BrokerDue"> | string
    amount?: FloatWithAggregatesFilter<"BrokerDue"> | number
    dueDate?: DateTimeWithAggregatesFilter<"BrokerDue"> | Date | string
    status?: StringWithAggregatesFilter<"BrokerDue"> | string
    notes?: StringNullableWithAggregatesFilter<"BrokerDue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BrokerDue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BrokerDue"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BrokerDue"> | Date | string | null
  }

  export type PartnerGroupWhereInput = {
    AND?: PartnerGroupWhereInput | PartnerGroupWhereInput[]
    OR?: PartnerGroupWhereInput[]
    NOT?: PartnerGroupWhereInput | PartnerGroupWhereInput[]
    id?: StringFilter<"PartnerGroup"> | string
    name?: StringFilter<"PartnerGroup"> | string
    notes?: StringNullableFilter<"PartnerGroup"> | string | null
    createdAt?: DateTimeFilter<"PartnerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerGroup"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerGroup"> | Date | string | null
    partners?: PartnerGroupPartnerListRelationFilter
  }

  export type PartnerGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    partners?: PartnerGroupPartnerOrderByRelationAggregateInput
  }

  export type PartnerGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PartnerGroupWhereInput | PartnerGroupWhereInput[]
    OR?: PartnerGroupWhereInput[]
    NOT?: PartnerGroupWhereInput | PartnerGroupWhereInput[]
    notes?: StringNullableFilter<"PartnerGroup"> | string | null
    createdAt?: DateTimeFilter<"PartnerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerGroup"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerGroup"> | Date | string | null
    partners?: PartnerGroupPartnerListRelationFilter
  }, "id" | "name">

  export type PartnerGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PartnerGroupCountOrderByAggregateInput
    _max?: PartnerGroupMaxOrderByAggregateInput
    _min?: PartnerGroupMinOrderByAggregateInput
  }

  export type PartnerGroupScalarWhereWithAggregatesInput = {
    AND?: PartnerGroupScalarWhereWithAggregatesInput | PartnerGroupScalarWhereWithAggregatesInput[]
    OR?: PartnerGroupScalarWhereWithAggregatesInput[]
    NOT?: PartnerGroupScalarWhereWithAggregatesInput | PartnerGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerGroup"> | string
    name?: StringWithAggregatesFilter<"PartnerGroup"> | string
    notes?: StringNullableWithAggregatesFilter<"PartnerGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PartnerGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerGroup"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PartnerGroup"> | Date | string | null
  }

  export type PartnerGroupPartnerWhereInput = {
    AND?: PartnerGroupPartnerWhereInput | PartnerGroupPartnerWhereInput[]
    OR?: PartnerGroupPartnerWhereInput[]
    NOT?: PartnerGroupPartnerWhereInput | PartnerGroupPartnerWhereInput[]
    id?: StringFilter<"PartnerGroupPartner"> | string
    partnerGroupId?: StringFilter<"PartnerGroupPartner"> | string
    partnerId?: StringFilter<"PartnerGroupPartner"> | string
    percentage?: FloatFilter<"PartnerGroupPartner"> | number
    createdAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerGroupPartner"> | Date | string | null
    partnerGroup?: XOR<PartnerGroupScalarRelationFilter, PartnerGroupWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type PartnerGroupPartnerOrderByWithRelationInput = {
    id?: SortOrder
    partnerGroupId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    partnerGroup?: PartnerGroupOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerGroupPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    partnerGroupId_partnerId?: PartnerGroupPartnerPartnerGroupIdPartnerIdCompoundUniqueInput
    AND?: PartnerGroupPartnerWhereInput | PartnerGroupPartnerWhereInput[]
    OR?: PartnerGroupPartnerWhereInput[]
    NOT?: PartnerGroupPartnerWhereInput | PartnerGroupPartnerWhereInput[]
    partnerGroupId?: StringFilter<"PartnerGroupPartner"> | string
    partnerId?: StringFilter<"PartnerGroupPartner"> | string
    percentage?: FloatFilter<"PartnerGroupPartner"> | number
    createdAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerGroupPartner"> | Date | string | null
    partnerGroup?: XOR<PartnerGroupScalarRelationFilter, PartnerGroupWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id" | "partnerGroupId_partnerId">

  export type PartnerGroupPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    partnerGroupId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PartnerGroupPartnerCountOrderByAggregateInput
    _avg?: PartnerGroupPartnerAvgOrderByAggregateInput
    _max?: PartnerGroupPartnerMaxOrderByAggregateInput
    _min?: PartnerGroupPartnerMinOrderByAggregateInput
    _sum?: PartnerGroupPartnerSumOrderByAggregateInput
  }

  export type PartnerGroupPartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerGroupPartnerScalarWhereWithAggregatesInput | PartnerGroupPartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerGroupPartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerGroupPartnerScalarWhereWithAggregatesInput | PartnerGroupPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerGroupPartner"> | string
    partnerGroupId?: StringWithAggregatesFilter<"PartnerGroupPartner"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerGroupPartner"> | string
    percentage?: FloatWithAggregatesFilter<"PartnerGroupPartner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PartnerGroupPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerGroupPartner"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PartnerGroupPartner"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: StringNullableFilter<"AuditLog"> | string | null
    newValues?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: StringNullableFilter<"AuditLog"> | string | null
    newValues?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValues?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    value?: StringFilter<"Settings"> | string
  }, "id" | "key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: StringWithAggregatesFilter<"Settings"> | string
  }

  export type KeyValWhereInput = {
    AND?: KeyValWhereInput | KeyValWhereInput[]
    OR?: KeyValWhereInput[]
    NOT?: KeyValWhereInput | KeyValWhereInput[]
    id?: StringFilter<"KeyVal"> | string
    key?: StringFilter<"KeyVal"> | string
    value?: StringFilter<"KeyVal"> | string
  }

  export type KeyValOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: KeyValWhereInput | KeyValWhereInput[]
    OR?: KeyValWhereInput[]
    NOT?: KeyValWhereInput | KeyValWhereInput[]
    value?: StringFilter<"KeyVal"> | string
  }, "id" | "key">

  export type KeyValOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: KeyValCountOrderByAggregateInput
    _max?: KeyValMaxOrderByAggregateInput
    _min?: KeyValMinOrderByAggregateInput
  }

  export type KeyValScalarWhereWithAggregatesInput = {
    AND?: KeyValScalarWhereWithAggregatesInput | KeyValScalarWhereWithAggregatesInput[]
    OR?: KeyValScalarWhereWithAggregatesInput[]
    NOT?: KeyValScalarWhereWithAggregatesInput | KeyValScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeyVal"> | string
    key?: StringWithAggregatesFilter<"KeyVal"> | string
    value?: StringWithAggregatesFilter<"KeyVal"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    category?: StringFilter<"Notification"> | string
    acknowledged?: BoolFilter<"Notification"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    data?: StringNullableFilter<"Notification"> | string | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    category?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    category?: StringFilter<"Notification"> | string
    acknowledged?: BoolFilter<"Notification"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    data?: StringNullableFilter<"Notification"> | string | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    category?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    category?: StringWithAggregatesFilter<"Notification"> | string
    acknowledged?: BoolWithAggregatesFilter<"Notification"> | boolean
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    phone?: string | null
    nationalId?: string | null
    address?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    nationalId?: string | null
    address?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    nationalId?: string | null
    address?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitCreateInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractCreateNestedManyWithoutUnitInput
    installments?: InstallmentCreateNestedManyWithoutUnitInput
    vouchers?: VoucherCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutUnitInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutUnitInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUncheckedUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerCreateNestedManyWithoutPartnerInput
    partnerDebts?: PartnerDebtCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutPartnerInput
    partnerDebts?: PartnerDebtUncheckedCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUpdateManyWithoutPartnerNestedInput
    partnerDebts?: PartnerDebtUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutPartnerNestedInput
    partnerDebts?: PartnerDebtUncheckedUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerCreateInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutUnitPartnersInput
    partner: PartnerCreateNestedOneWithoutUnitPartnersInput
  }

  export type UnitPartnerUncheckedCreateInput = {
    id?: string
    unitId: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutUnitPartnersNestedInput
    partner?: PartnerUpdateOneRequiredWithoutUnitPartnersNestedInput
  }

  export type UnitPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerCreateManyInput = {
    id?: string
    unitId: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateInput = {
    id?: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutContractsInput
    customer: CustomerCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    unitId: string
    customerId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutContractsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateManyInput = {
    id?: string
    unitId: string
    customerId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentCreateInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateInput = {
    id?: string
    unitId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentCreateManyInput = {
    id?: string
    unitId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtCreateInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partner: PartnerCreateNestedOneWithoutPartnerDebtsInput
  }

  export type PartnerDebtUncheckedCreateInput = {
    id?: string
    partnerId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerDebtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partner?: PartnerUpdateOneRequiredWithoutPartnerDebtsNestedInput
  }

  export type PartnerDebtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtCreateManyInput = {
    id?: string
    partnerId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerDebtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SafeCreateInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherCreateNestedManyWithoutSafeInput
    transfersFrom?: TransferCreateNestedManyWithoutFromSafeInput
    transfersTo?: TransferCreateNestedManyWithoutToSafeInput
  }

  export type SafeUncheckedCreateInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherUncheckedCreateNestedManyWithoutSafeInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromSafeInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToSafeInput
  }

  export type SafeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUpdateManyWithoutSafeNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromSafeNestedInput
    transfersTo?: TransferUpdateManyWithoutToSafeNestedInput
  }

  export type SafeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUncheckedUpdateManyWithoutSafeNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromSafeNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToSafeNestedInput
  }

  export type SafeCreateManyInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SafeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SafeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferCreateInput = {
    id?: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fromSafe: SafeCreateNestedOneWithoutTransfersFromInput
    toSafe: SafeCreateNestedOneWithoutTransfersToInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    fromSafeId: string
    toSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromSafe?: SafeUpdateOneRequiredWithoutTransfersFromNestedInput
    toSafe?: SafeUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromSafeId?: StringFieldUpdateOperationsInput | string
    toSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferCreateManyInput = {
    id?: string
    fromSafeId: string
    toSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromSafeId?: StringFieldUpdateOperationsInput | string
    toSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    description: string
    payer?: string | null
    beneficiary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    safe: SafeCreateNestedOneWithoutVouchersInput
    unit?: UnitCreateNestedOneWithoutVouchersInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    safeId: string
    description: string
    payer?: string | null
    beneficiary?: string | null
    linkedRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    safe?: SafeUpdateOneRequiredWithoutVouchersNestedInput
    unit?: UnitUpdateOneWithoutVouchersNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    safeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    linkedRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateManyInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    safeId: string
    description: string
    payer?: string | null
    beneficiary?: string | null
    linkedRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    safeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    linkedRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerCreateInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    brokerDues?: BrokerDueCreateNestedManyWithoutBrokerInput
  }

  export type BrokerUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    brokerDues?: BrokerDueUncheckedCreateNestedManyWithoutBrokerInput
  }

  export type BrokerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerDues?: BrokerDueUpdateManyWithoutBrokerNestedInput
  }

  export type BrokerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerDues?: BrokerDueUncheckedUpdateManyWithoutBrokerNestedInput
  }

  export type BrokerCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueCreateInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    broker: BrokerCreateNestedOneWithoutBrokerDuesInput
  }

  export type BrokerDueUncheckedCreateInput = {
    id?: string
    brokerId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerDueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    broker?: BrokerUpdateOneRequiredWithoutBrokerDuesNestedInput
  }

  export type BrokerDueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brokerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueCreateManyInput = {
    id?: string
    brokerId: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerDueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brokerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupCreateInput = {
    id?: string
    name: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partners?: PartnerGroupPartnerCreateNestedManyWithoutPartnerGroupInput
  }

  export type PartnerGroupUncheckedCreateInput = {
    id?: string
    name: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partners?: PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerGroupInput
  }

  export type PartnerGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partners?: PartnerGroupPartnerUpdateManyWithoutPartnerGroupNestedInput
  }

  export type PartnerGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partners?: PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerGroupNestedInput
  }

  export type PartnerGroupCreateManyInput = {
    id?: string
    name: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerCreateInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partnerGroup: PartnerGroupCreateNestedOneWithoutPartnersInput
    partner: PartnerCreateNestedOneWithoutPartnerGroupPartnersInput
  }

  export type PartnerGroupPartnerUncheckedCreateInput = {
    id?: string
    partnerGroupId: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partnerGroup?: PartnerGroupUpdateOneRequiredWithoutPartnersNestedInput
    partner?: PartnerUpdateOneRequiredWithoutPartnerGroupPartnersNestedInput
  }

  export type PartnerGroupPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerGroupId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerCreateManyInput = {
    id?: string
    partnerGroupId: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerGroupId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: string | null
    newValues?: string | null
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: string | null
    newValues?: string | null
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: string | null
    newValues?: string | null
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    key: string
    value: string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValUncheckedCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValCreateManyInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    email?: string | null
    name?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    email?: string | null
    name?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    email?: string | null
    name?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    category: string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    data?: string | null
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    category: string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    data?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    title: string
    message: string
    category: string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    data?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    nationalId?: SortOrder
    address?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    nationalId?: SortOrder
    address?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    nationalId?: SortOrder
    address?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InstallmentListRelationFilter = {
    every?: InstallmentWhereInput
    some?: InstallmentWhereInput
    none?: InstallmentWhereInput
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type UnitPartnerListRelationFilter = {
    every?: UnitPartnerWhereInput
    some?: UnitPartnerWhereInput
    none?: UnitPartnerWhereInput
  }

  export type InstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unitType?: SortOrder
    area?: SortOrder
    floor?: SortOrder
    building?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unitType?: SortOrder
    area?: SortOrder
    floor?: SortOrder
    building?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unitType?: SortOrder
    area?: SortOrder
    floor?: SortOrder
    building?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PartnerDebtListRelationFilter = {
    every?: PartnerDebtWhereInput
    some?: PartnerDebtWhereInput
    none?: PartnerDebtWhereInput
  }

  export type PartnerGroupPartnerListRelationFilter = {
    every?: PartnerGroupPartnerWhereInput
    some?: PartnerGroupPartnerWhereInput
    none?: PartnerGroupPartnerWhereInput
  }

  export type PartnerDebtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerGroupPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type PartnerScalarRelationFilter = {
    is?: PartnerWhereInput
    isNot?: PartnerWhereInput
  }

  export type UnitPartnerUnitIdPartnerIdCompoundUniqueInput = {
    unitId: string
    partnerId: string
  }

  export type UnitPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitPartnerAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type UnitPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UnitPartnerSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    customerId?: SortOrder
    start?: SortOrder
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerName?: SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    commissionSafeId?: SortOrder
    downPaymentSafeId?: SortOrder
    maintenanceDeposit?: SortOrder
    installmentType?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    maintenanceDeposit?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    customerId?: SortOrder
    start?: SortOrder
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerName?: SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    commissionSafeId?: SortOrder
    downPaymentSafeId?: SortOrder
    maintenanceDeposit?: SortOrder
    installmentType?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    customerId?: SortOrder
    start?: SortOrder
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerName?: SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    commissionSafeId?: SortOrder
    downPaymentSafeId?: SortOrder
    maintenanceDeposit?: SortOrder
    installmentType?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    discountAmount?: SortOrder
    brokerPercent?: SortOrder
    brokerAmount?: SortOrder
    maintenanceDeposit?: SortOrder
    installmentCount?: SortOrder
    extraAnnual?: SortOrder
    annualPaymentValue?: SortOrder
    downPayment?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InstallmentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InstallmentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PartnerDebtCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerDebtAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PartnerDebtMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerDebtMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerDebtSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SafeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SafeAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type SafeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SafeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SafeSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type SafeScalarRelationFilter = {
    is?: SafeWhereInput
    isNot?: SafeWhereInput
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    fromSafeId?: SortOrder
    toSafeId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    fromSafeId?: SortOrder
    toSafeId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    fromSafeId?: SortOrder
    toSafeId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    safeId?: SortOrder
    description?: SortOrder
    payer?: SortOrder
    beneficiary?: SortOrder
    linkedRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    safeId?: SortOrder
    description?: SortOrder
    payer?: SortOrder
    beneficiary?: SortOrder
    linkedRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    safeId?: SortOrder
    description?: SortOrder
    payer?: SortOrder
    beneficiary?: SortOrder
    linkedRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BrokerDueListRelationFilter = {
    every?: BrokerDueWhereInput
    some?: BrokerDueWhereInput
    none?: BrokerDueWhereInput
  }

  export type BrokerDueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrokerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerScalarRelationFilter = {
    is?: BrokerWhereInput
    isNot?: BrokerWhereInput
  }

  export type BrokerDueCountOrderByAggregateInput = {
    id?: SortOrder
    brokerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerDueAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BrokerDueMaxOrderByAggregateInput = {
    id?: SortOrder
    brokerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerDueMinOrderByAggregateInput = {
    id?: SortOrder
    brokerId?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BrokerDueSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PartnerGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupScalarRelationFilter = {
    is?: PartnerGroupWhereInput
    isNot?: PartnerGroupWhereInput
  }

  export type PartnerGroupPartnerPartnerGroupIdPartnerIdCompoundUniqueInput = {
    partnerGroupId: string
    partnerId: string
  }

  export type PartnerGroupPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    partnerGroupId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupPartnerAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type PartnerGroupPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerGroupId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    partnerGroupId?: SortOrder
    partnerId?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PartnerGroupPartnerSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    category?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    data?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    category?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    data?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    category?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    data?: SortOrder
  }

  export type ContractCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput> | ContractCreateWithoutCustomerInput[] | ContractUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCustomerInput | ContractCreateOrConnectWithoutCustomerInput[]
    createMany?: ContractCreateManyCustomerInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput> | ContractCreateWithoutCustomerInput[] | ContractUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCustomerInput | ContractCreateOrConnectWithoutCustomerInput[]
    createMany?: ContractCreateManyCustomerInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ContractUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput> | ContractCreateWithoutCustomerInput[] | ContractUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCustomerInput | ContractCreateOrConnectWithoutCustomerInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCustomerInput | ContractUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ContractCreateManyCustomerInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCustomerInput | ContractUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCustomerInput | ContractUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput> | ContractCreateWithoutCustomerInput[] | ContractUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCustomerInput | ContractCreateOrConnectWithoutCustomerInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCustomerInput | ContractUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ContractCreateManyCustomerInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCustomerInput | ContractUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCustomerInput | ContractUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ContractCreateNestedManyWithoutUnitInput = {
    create?: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput> | ContractCreateWithoutUnitInput[] | ContractUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutUnitInput | ContractCreateOrConnectWithoutUnitInput[]
    createMany?: ContractCreateManyUnitInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type InstallmentCreateNestedManyWithoutUnitInput = {
    create?: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput> | InstallmentCreateWithoutUnitInput[] | InstallmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutUnitInput | InstallmentCreateOrConnectWithoutUnitInput[]
    createMany?: InstallmentCreateManyUnitInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutUnitInput = {
    create?: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput> | VoucherCreateWithoutUnitInput[] | VoucherUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUnitInput | VoucherCreateOrConnectWithoutUnitInput[]
    createMany?: VoucherCreateManyUnitInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type UnitPartnerCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput> | UnitPartnerCreateWithoutUnitInput[] | UnitPartnerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutUnitInput | UnitPartnerCreateOrConnectWithoutUnitInput[]
    createMany?: UnitPartnerCreateManyUnitInputEnvelope
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput> | ContractCreateWithoutUnitInput[] | ContractUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutUnitInput | ContractCreateOrConnectWithoutUnitInput[]
    createMany?: ContractCreateManyUnitInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type InstallmentUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput> | InstallmentCreateWithoutUnitInput[] | InstallmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutUnitInput | InstallmentCreateOrConnectWithoutUnitInput[]
    createMany?: InstallmentCreateManyUnitInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput> | VoucherCreateWithoutUnitInput[] | VoucherUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUnitInput | VoucherCreateOrConnectWithoutUnitInput[]
    createMany?: VoucherCreateManyUnitInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type UnitPartnerUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput> | UnitPartnerCreateWithoutUnitInput[] | UnitPartnerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutUnitInput | UnitPartnerCreateOrConnectWithoutUnitInput[]
    createMany?: UnitPartnerCreateManyUnitInputEnvelope
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContractUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput> | ContractCreateWithoutUnitInput[] | ContractUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutUnitInput | ContractCreateOrConnectWithoutUnitInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutUnitInput | ContractUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ContractCreateManyUnitInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutUnitInput | ContractUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutUnitInput | ContractUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type InstallmentUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput> | InstallmentCreateWithoutUnitInput[] | InstallmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutUnitInput | InstallmentCreateOrConnectWithoutUnitInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutUnitInput | InstallmentUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InstallmentCreateManyUnitInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutUnitInput | InstallmentUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutUnitInput | InstallmentUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput> | VoucherCreateWithoutUnitInput[] | VoucherUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUnitInput | VoucherCreateOrConnectWithoutUnitInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutUnitInput | VoucherUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VoucherCreateManyUnitInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutUnitInput | VoucherUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutUnitInput | VoucherUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type UnitPartnerUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput> | UnitPartnerCreateWithoutUnitInput[] | UnitPartnerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutUnitInput | UnitPartnerCreateOrConnectWithoutUnitInput[]
    upsert?: UnitPartnerUpsertWithWhereUniqueWithoutUnitInput | UnitPartnerUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitPartnerCreateManyUnitInputEnvelope
    set?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    disconnect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    delete?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    update?: UnitPartnerUpdateWithWhereUniqueWithoutUnitInput | UnitPartnerUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitPartnerUpdateManyWithWhereWithoutUnitInput | UnitPartnerUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput> | ContractCreateWithoutUnitInput[] | ContractUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutUnitInput | ContractCreateOrConnectWithoutUnitInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutUnitInput | ContractUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ContractCreateManyUnitInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutUnitInput | ContractUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutUnitInput | ContractUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type InstallmentUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput> | InstallmentCreateWithoutUnitInput[] | InstallmentUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutUnitInput | InstallmentCreateOrConnectWithoutUnitInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutUnitInput | InstallmentUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InstallmentCreateManyUnitInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutUnitInput | InstallmentUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutUnitInput | InstallmentUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput> | VoucherCreateWithoutUnitInput[] | VoucherUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUnitInput | VoucherCreateOrConnectWithoutUnitInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutUnitInput | VoucherUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: VoucherCreateManyUnitInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutUnitInput | VoucherUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutUnitInput | VoucherUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type UnitPartnerUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput> | UnitPartnerCreateWithoutUnitInput[] | UnitPartnerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutUnitInput | UnitPartnerCreateOrConnectWithoutUnitInput[]
    upsert?: UnitPartnerUpsertWithWhereUniqueWithoutUnitInput | UnitPartnerUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitPartnerCreateManyUnitInputEnvelope
    set?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    disconnect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    delete?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    update?: UnitPartnerUpdateWithWhereUniqueWithoutUnitInput | UnitPartnerUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitPartnerUpdateManyWithWhereWithoutUnitInput | UnitPartnerUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
  }

  export type UnitPartnerCreateNestedManyWithoutPartnerInput = {
    create?: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput> | UnitPartnerCreateWithoutPartnerInput[] | UnitPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutPartnerInput | UnitPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: UnitPartnerCreateManyPartnerInputEnvelope
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
  }

  export type PartnerDebtCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput> | PartnerDebtCreateWithoutPartnerInput[] | PartnerDebtUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDebtCreateOrConnectWithoutPartnerInput | PartnerDebtCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerDebtCreateManyPartnerInputEnvelope
    connect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
  }

  export type PartnerGroupPartnerCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput> | PartnerGroupPartnerCreateWithoutPartnerInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerInputEnvelope
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
  }

  export type UnitPartnerUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput> | UnitPartnerCreateWithoutPartnerInput[] | UnitPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutPartnerInput | UnitPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: UnitPartnerCreateManyPartnerInputEnvelope
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
  }

  export type PartnerDebtUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput> | PartnerDebtCreateWithoutPartnerInput[] | PartnerDebtUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDebtCreateOrConnectWithoutPartnerInput | PartnerDebtCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerDebtCreateManyPartnerInputEnvelope
    connect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
  }

  export type PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput> | PartnerGroupPartnerCreateWithoutPartnerInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerInputEnvelope
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
  }

  export type UnitPartnerUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput> | UnitPartnerCreateWithoutPartnerInput[] | UnitPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutPartnerInput | UnitPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: UnitPartnerUpsertWithWhereUniqueWithoutPartnerInput | UnitPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: UnitPartnerCreateManyPartnerInputEnvelope
    set?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    disconnect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    delete?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    update?: UnitPartnerUpdateWithWhereUniqueWithoutPartnerInput | UnitPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: UnitPartnerUpdateManyWithWhereWithoutPartnerInput | UnitPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
  }

  export type PartnerDebtUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput> | PartnerDebtCreateWithoutPartnerInput[] | PartnerDebtUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDebtCreateOrConnectWithoutPartnerInput | PartnerDebtCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerDebtUpsertWithWhereUniqueWithoutPartnerInput | PartnerDebtUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerDebtCreateManyPartnerInputEnvelope
    set?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    disconnect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    delete?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    connect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    update?: PartnerDebtUpdateWithWhereUniqueWithoutPartnerInput | PartnerDebtUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerDebtUpdateManyWithWhereWithoutPartnerInput | PartnerDebtUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerDebtScalarWhereInput | PartnerDebtScalarWhereInput[]
  }

  export type PartnerGroupPartnerUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput> | PartnerGroupPartnerCreateWithoutPartnerInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerInput | PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerInputEnvelope
    set?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    disconnect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    delete?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    update?: PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerInput | PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerInput | PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
  }

  export type UnitPartnerUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput> | UnitPartnerCreateWithoutPartnerInput[] | UnitPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: UnitPartnerCreateOrConnectWithoutPartnerInput | UnitPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: UnitPartnerUpsertWithWhereUniqueWithoutPartnerInput | UnitPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: UnitPartnerCreateManyPartnerInputEnvelope
    set?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    disconnect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    delete?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    connect?: UnitPartnerWhereUniqueInput | UnitPartnerWhereUniqueInput[]
    update?: UnitPartnerUpdateWithWhereUniqueWithoutPartnerInput | UnitPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: UnitPartnerUpdateManyWithWhereWithoutPartnerInput | UnitPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
  }

  export type PartnerDebtUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput> | PartnerDebtCreateWithoutPartnerInput[] | PartnerDebtUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDebtCreateOrConnectWithoutPartnerInput | PartnerDebtCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerDebtUpsertWithWhereUniqueWithoutPartnerInput | PartnerDebtUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerDebtCreateManyPartnerInputEnvelope
    set?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    disconnect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    delete?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    connect?: PartnerDebtWhereUniqueInput | PartnerDebtWhereUniqueInput[]
    update?: PartnerDebtUpdateWithWhereUniqueWithoutPartnerInput | PartnerDebtUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerDebtUpdateManyWithWhereWithoutPartnerInput | PartnerDebtUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerDebtScalarWhereInput | PartnerDebtScalarWhereInput[]
  }

  export type PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput> | PartnerGroupPartnerCreateWithoutPartnerInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerInput | PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerInputEnvelope
    set?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    disconnect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    delete?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    update?: PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerInput | PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerInput | PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutUnitPartnersInput = {
    create?: XOR<UnitCreateWithoutUnitPartnersInput, UnitUncheckedCreateWithoutUnitPartnersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnitPartnersInput
    connect?: UnitWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutUnitPartnersInput = {
    create?: XOR<PartnerCreateWithoutUnitPartnersInput, PartnerUncheckedCreateWithoutUnitPartnersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUnitPartnersInput
    connect?: PartnerWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutUnitPartnersNestedInput = {
    create?: XOR<UnitCreateWithoutUnitPartnersInput, UnitUncheckedCreateWithoutUnitPartnersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnitPartnersInput
    upsert?: UnitUpsertWithoutUnitPartnersInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnitPartnersInput, UnitUpdateWithoutUnitPartnersInput>, UnitUncheckedUpdateWithoutUnitPartnersInput>
  }

  export type PartnerUpdateOneRequiredWithoutUnitPartnersNestedInput = {
    create?: XOR<PartnerCreateWithoutUnitPartnersInput, PartnerUncheckedCreateWithoutUnitPartnersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUnitPartnersInput
    upsert?: PartnerUpsertWithoutUnitPartnersInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutUnitPartnersInput, PartnerUpdateWithoutUnitPartnersInput>, PartnerUncheckedUpdateWithoutUnitPartnersInput>
  }

  export type UnitCreateNestedOneWithoutContractsInput = {
    create?: XOR<UnitCreateWithoutContractsInput, UnitUncheckedCreateWithoutContractsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutContractsInput
    connect?: UnitWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutContractsInput = {
    create?: XOR<CustomerCreateWithoutContractsInput, CustomerUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContractsInput
    connect?: CustomerWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<UnitCreateWithoutContractsInput, UnitUncheckedCreateWithoutContractsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutContractsInput
    upsert?: UnitUpsertWithoutContractsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutContractsInput, UnitUpdateWithoutContractsInput>, UnitUncheckedUpdateWithoutContractsInput>
  }

  export type CustomerUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<CustomerCreateWithoutContractsInput, CustomerUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutContractsInput
    upsert?: CustomerUpsertWithoutContractsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutContractsInput, CustomerUpdateWithoutContractsInput>, CustomerUncheckedUpdateWithoutContractsInput>
  }

  export type UnitCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<UnitCreateWithoutInstallmentsInput, UnitUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutInstallmentsInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<UnitCreateWithoutInstallmentsInput, UnitUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutInstallmentsInput
    upsert?: UnitUpsertWithoutInstallmentsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutInstallmentsInput, UnitUpdateWithoutInstallmentsInput>, UnitUncheckedUpdateWithoutInstallmentsInput>
  }

  export type PartnerCreateNestedOneWithoutPartnerDebtsInput = {
    create?: XOR<PartnerCreateWithoutPartnerDebtsInput, PartnerUncheckedCreateWithoutPartnerDebtsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerDebtsInput
    connect?: PartnerWhereUniqueInput
  }

  export type PartnerUpdateOneRequiredWithoutPartnerDebtsNestedInput = {
    create?: XOR<PartnerCreateWithoutPartnerDebtsInput, PartnerUncheckedCreateWithoutPartnerDebtsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerDebtsInput
    upsert?: PartnerUpsertWithoutPartnerDebtsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutPartnerDebtsInput, PartnerUpdateWithoutPartnerDebtsInput>, PartnerUncheckedUpdateWithoutPartnerDebtsInput>
  }

  export type VoucherCreateNestedManyWithoutSafeInput = {
    create?: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput> | VoucherCreateWithoutSafeInput[] | VoucherUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutSafeInput | VoucherCreateOrConnectWithoutSafeInput[]
    createMany?: VoucherCreateManySafeInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromSafeInput = {
    create?: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput> | TransferCreateWithoutFromSafeInput[] | TransferUncheckedCreateWithoutFromSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromSafeInput | TransferCreateOrConnectWithoutFromSafeInput[]
    createMany?: TransferCreateManyFromSafeInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToSafeInput = {
    create?: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput> | TransferCreateWithoutToSafeInput[] | TransferUncheckedCreateWithoutToSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToSafeInput | TransferCreateOrConnectWithoutToSafeInput[]
    createMany?: TransferCreateManyToSafeInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutSafeInput = {
    create?: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput> | VoucherCreateWithoutSafeInput[] | VoucherUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutSafeInput | VoucherCreateOrConnectWithoutSafeInput[]
    createMany?: VoucherCreateManySafeInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromSafeInput = {
    create?: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput> | TransferCreateWithoutFromSafeInput[] | TransferUncheckedCreateWithoutFromSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromSafeInput | TransferCreateOrConnectWithoutFromSafeInput[]
    createMany?: TransferCreateManyFromSafeInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToSafeInput = {
    create?: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput> | TransferCreateWithoutToSafeInput[] | TransferUncheckedCreateWithoutToSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToSafeInput | TransferCreateOrConnectWithoutToSafeInput[]
    createMany?: TransferCreateManyToSafeInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type VoucherUpdateManyWithoutSafeNestedInput = {
    create?: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput> | VoucherCreateWithoutSafeInput[] | VoucherUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutSafeInput | VoucherCreateOrConnectWithoutSafeInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutSafeInput | VoucherUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: VoucherCreateManySafeInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutSafeInput | VoucherUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutSafeInput | VoucherUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromSafeNestedInput = {
    create?: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput> | TransferCreateWithoutFromSafeInput[] | TransferUncheckedCreateWithoutFromSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromSafeInput | TransferCreateOrConnectWithoutFromSafeInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromSafeInput | TransferUpsertWithWhereUniqueWithoutFromSafeInput[]
    createMany?: TransferCreateManyFromSafeInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromSafeInput | TransferUpdateWithWhereUniqueWithoutFromSafeInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromSafeInput | TransferUpdateManyWithWhereWithoutFromSafeInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToSafeNestedInput = {
    create?: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput> | TransferCreateWithoutToSafeInput[] | TransferUncheckedCreateWithoutToSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToSafeInput | TransferCreateOrConnectWithoutToSafeInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToSafeInput | TransferUpsertWithWhereUniqueWithoutToSafeInput[]
    createMany?: TransferCreateManyToSafeInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToSafeInput | TransferUpdateWithWhereUniqueWithoutToSafeInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToSafeInput | TransferUpdateManyWithWhereWithoutToSafeInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutSafeNestedInput = {
    create?: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput> | VoucherCreateWithoutSafeInput[] | VoucherUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutSafeInput | VoucherCreateOrConnectWithoutSafeInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutSafeInput | VoucherUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: VoucherCreateManySafeInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutSafeInput | VoucherUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutSafeInput | VoucherUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromSafeNestedInput = {
    create?: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput> | TransferCreateWithoutFromSafeInput[] | TransferUncheckedCreateWithoutFromSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromSafeInput | TransferCreateOrConnectWithoutFromSafeInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromSafeInput | TransferUpsertWithWhereUniqueWithoutFromSafeInput[]
    createMany?: TransferCreateManyFromSafeInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromSafeInput | TransferUpdateWithWhereUniqueWithoutFromSafeInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromSafeInput | TransferUpdateManyWithWhereWithoutFromSafeInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToSafeNestedInput = {
    create?: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput> | TransferCreateWithoutToSafeInput[] | TransferUncheckedCreateWithoutToSafeInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToSafeInput | TransferCreateOrConnectWithoutToSafeInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToSafeInput | TransferUpsertWithWhereUniqueWithoutToSafeInput[]
    createMany?: TransferCreateManyToSafeInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToSafeInput | TransferUpdateWithWhereUniqueWithoutToSafeInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToSafeInput | TransferUpdateManyWithWhereWithoutToSafeInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type SafeCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<SafeCreateWithoutTransfersFromInput, SafeUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: SafeCreateOrConnectWithoutTransfersFromInput
    connect?: SafeWhereUniqueInput
  }

  export type SafeCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<SafeCreateWithoutTransfersToInput, SafeUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: SafeCreateOrConnectWithoutTransfersToInput
    connect?: SafeWhereUniqueInput
  }

  export type SafeUpdateOneRequiredWithoutTransfersFromNestedInput = {
    create?: XOR<SafeCreateWithoutTransfersFromInput, SafeUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: SafeCreateOrConnectWithoutTransfersFromInput
    upsert?: SafeUpsertWithoutTransfersFromInput
    connect?: SafeWhereUniqueInput
    update?: XOR<XOR<SafeUpdateToOneWithWhereWithoutTransfersFromInput, SafeUpdateWithoutTransfersFromInput>, SafeUncheckedUpdateWithoutTransfersFromInput>
  }

  export type SafeUpdateOneRequiredWithoutTransfersToNestedInput = {
    create?: XOR<SafeCreateWithoutTransfersToInput, SafeUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: SafeCreateOrConnectWithoutTransfersToInput
    upsert?: SafeUpsertWithoutTransfersToInput
    connect?: SafeWhereUniqueInput
    update?: XOR<XOR<SafeUpdateToOneWithWhereWithoutTransfersToInput, SafeUpdateWithoutTransfersToInput>, SafeUncheckedUpdateWithoutTransfersToInput>
  }

  export type SafeCreateNestedOneWithoutVouchersInput = {
    create?: XOR<SafeCreateWithoutVouchersInput, SafeUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: SafeCreateOrConnectWithoutVouchersInput
    connect?: SafeWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutVouchersInput = {
    create?: XOR<UnitCreateWithoutVouchersInput, UnitUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVouchersInput
    connect?: UnitWhereUniqueInput
  }

  export type SafeUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<SafeCreateWithoutVouchersInput, SafeUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: SafeCreateOrConnectWithoutVouchersInput
    upsert?: SafeUpsertWithoutVouchersInput
    connect?: SafeWhereUniqueInput
    update?: XOR<XOR<SafeUpdateToOneWithWhereWithoutVouchersInput, SafeUpdateWithoutVouchersInput>, SafeUncheckedUpdateWithoutVouchersInput>
  }

  export type UnitUpdateOneWithoutVouchersNestedInput = {
    create?: XOR<UnitCreateWithoutVouchersInput, UnitUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutVouchersInput
    upsert?: UnitUpsertWithoutVouchersInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutVouchersInput, UnitUpdateWithoutVouchersInput>, UnitUncheckedUpdateWithoutVouchersInput>
  }

  export type BrokerDueCreateNestedManyWithoutBrokerInput = {
    create?: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput> | BrokerDueCreateWithoutBrokerInput[] | BrokerDueUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: BrokerDueCreateOrConnectWithoutBrokerInput | BrokerDueCreateOrConnectWithoutBrokerInput[]
    createMany?: BrokerDueCreateManyBrokerInputEnvelope
    connect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
  }

  export type BrokerDueUncheckedCreateNestedManyWithoutBrokerInput = {
    create?: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput> | BrokerDueCreateWithoutBrokerInput[] | BrokerDueUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: BrokerDueCreateOrConnectWithoutBrokerInput | BrokerDueCreateOrConnectWithoutBrokerInput[]
    createMany?: BrokerDueCreateManyBrokerInputEnvelope
    connect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
  }

  export type BrokerDueUpdateManyWithoutBrokerNestedInput = {
    create?: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput> | BrokerDueCreateWithoutBrokerInput[] | BrokerDueUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: BrokerDueCreateOrConnectWithoutBrokerInput | BrokerDueCreateOrConnectWithoutBrokerInput[]
    upsert?: BrokerDueUpsertWithWhereUniqueWithoutBrokerInput | BrokerDueUpsertWithWhereUniqueWithoutBrokerInput[]
    createMany?: BrokerDueCreateManyBrokerInputEnvelope
    set?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    disconnect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    delete?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    connect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    update?: BrokerDueUpdateWithWhereUniqueWithoutBrokerInput | BrokerDueUpdateWithWhereUniqueWithoutBrokerInput[]
    updateMany?: BrokerDueUpdateManyWithWhereWithoutBrokerInput | BrokerDueUpdateManyWithWhereWithoutBrokerInput[]
    deleteMany?: BrokerDueScalarWhereInput | BrokerDueScalarWhereInput[]
  }

  export type BrokerDueUncheckedUpdateManyWithoutBrokerNestedInput = {
    create?: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput> | BrokerDueCreateWithoutBrokerInput[] | BrokerDueUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: BrokerDueCreateOrConnectWithoutBrokerInput | BrokerDueCreateOrConnectWithoutBrokerInput[]
    upsert?: BrokerDueUpsertWithWhereUniqueWithoutBrokerInput | BrokerDueUpsertWithWhereUniqueWithoutBrokerInput[]
    createMany?: BrokerDueCreateManyBrokerInputEnvelope
    set?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    disconnect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    delete?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    connect?: BrokerDueWhereUniqueInput | BrokerDueWhereUniqueInput[]
    update?: BrokerDueUpdateWithWhereUniqueWithoutBrokerInput | BrokerDueUpdateWithWhereUniqueWithoutBrokerInput[]
    updateMany?: BrokerDueUpdateManyWithWhereWithoutBrokerInput | BrokerDueUpdateManyWithWhereWithoutBrokerInput[]
    deleteMany?: BrokerDueScalarWhereInput | BrokerDueScalarWhereInput[]
  }

  export type BrokerCreateNestedOneWithoutBrokerDuesInput = {
    create?: XOR<BrokerCreateWithoutBrokerDuesInput, BrokerUncheckedCreateWithoutBrokerDuesInput>
    connectOrCreate?: BrokerCreateOrConnectWithoutBrokerDuesInput
    connect?: BrokerWhereUniqueInput
  }

  export type BrokerUpdateOneRequiredWithoutBrokerDuesNestedInput = {
    create?: XOR<BrokerCreateWithoutBrokerDuesInput, BrokerUncheckedCreateWithoutBrokerDuesInput>
    connectOrCreate?: BrokerCreateOrConnectWithoutBrokerDuesInput
    upsert?: BrokerUpsertWithoutBrokerDuesInput
    connect?: BrokerWhereUniqueInput
    update?: XOR<XOR<BrokerUpdateToOneWithWhereWithoutBrokerDuesInput, BrokerUpdateWithoutBrokerDuesInput>, BrokerUncheckedUpdateWithoutBrokerDuesInput>
  }

  export type PartnerGroupPartnerCreateNestedManyWithoutPartnerGroupInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput> | PartnerGroupPartnerCreateWithoutPartnerGroupInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerGroupInputEnvelope
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
  }

  export type PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerGroupInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput> | PartnerGroupPartnerCreateWithoutPartnerGroupInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerGroupInputEnvelope
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
  }

  export type PartnerGroupPartnerUpdateManyWithoutPartnerGroupNestedInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput> | PartnerGroupPartnerCreateWithoutPartnerGroupInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput[]
    upsert?: PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerGroupInput | PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerGroupInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerGroupInputEnvelope
    set?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    disconnect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    delete?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    update?: PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerGroupInput | PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerGroupInput[]
    updateMany?: PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerGroupInput | PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerGroupInput[]
    deleteMany?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
  }

  export type PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerGroupNestedInput = {
    create?: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput> | PartnerGroupPartnerCreateWithoutPartnerGroupInput[] | PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput[]
    connectOrCreate?: PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput | PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput[]
    upsert?: PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerGroupInput | PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerGroupInput[]
    createMany?: PartnerGroupPartnerCreateManyPartnerGroupInputEnvelope
    set?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    disconnect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    delete?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    connect?: PartnerGroupPartnerWhereUniqueInput | PartnerGroupPartnerWhereUniqueInput[]
    update?: PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerGroupInput | PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerGroupInput[]
    updateMany?: PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerGroupInput | PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerGroupInput[]
    deleteMany?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
  }

  export type PartnerGroupCreateNestedOneWithoutPartnersInput = {
    create?: XOR<PartnerGroupCreateWithoutPartnersInput, PartnerGroupUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: PartnerGroupCreateOrConnectWithoutPartnersInput
    connect?: PartnerGroupWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutPartnerGroupPartnersInput = {
    create?: XOR<PartnerCreateWithoutPartnerGroupPartnersInput, PartnerUncheckedCreateWithoutPartnerGroupPartnersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerGroupPartnersInput
    connect?: PartnerWhereUniqueInput
  }

  export type PartnerGroupUpdateOneRequiredWithoutPartnersNestedInput = {
    create?: XOR<PartnerGroupCreateWithoutPartnersInput, PartnerGroupUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: PartnerGroupCreateOrConnectWithoutPartnersInput
    upsert?: PartnerGroupUpsertWithoutPartnersInput
    connect?: PartnerGroupWhereUniqueInput
    update?: XOR<XOR<PartnerGroupUpdateToOneWithWhereWithoutPartnersInput, PartnerGroupUpdateWithoutPartnersInput>, PartnerGroupUncheckedUpdateWithoutPartnersInput>
  }

  export type PartnerUpdateOneRequiredWithoutPartnerGroupPartnersNestedInput = {
    create?: XOR<PartnerCreateWithoutPartnerGroupPartnersInput, PartnerUncheckedCreateWithoutPartnerGroupPartnersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerGroupPartnersInput
    upsert?: PartnerUpsertWithoutPartnerGroupPartnersInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutPartnerGroupPartnersInput, PartnerUpdateWithoutPartnerGroupPartnersInput>, PartnerUncheckedUpdateWithoutPartnerGroupPartnersInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ContractCreateWithoutCustomerInput = {
    id?: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateWithoutCustomerInput = {
    id?: string
    unitId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractCreateOrConnectWithoutCustomerInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput>
  }

  export type ContractCreateManyCustomerInputEnvelope = {
    data: ContractCreateManyCustomerInput | ContractCreateManyCustomerInput[]
  }

  export type ContractUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutCustomerInput, ContractUncheckedUpdateWithoutCustomerInput>
    create: XOR<ContractCreateWithoutCustomerInput, ContractUncheckedCreateWithoutCustomerInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutCustomerInput, ContractUncheckedUpdateWithoutCustomerInput>
  }

  export type ContractUpdateManyWithWhereWithoutCustomerInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    unitId?: StringFilter<"Contract"> | string
    customerId?: StringFilter<"Contract"> | string
    start?: DateTimeFilter<"Contract"> | Date | string
    totalPrice?: FloatFilter<"Contract"> | number
    discountAmount?: FloatFilter<"Contract"> | number
    brokerName?: StringNullableFilter<"Contract"> | string | null
    brokerPercent?: FloatFilter<"Contract"> | number
    brokerAmount?: FloatFilter<"Contract"> | number
    commissionSafeId?: StringNullableFilter<"Contract"> | string | null
    downPaymentSafeId?: StringNullableFilter<"Contract"> | string | null
    maintenanceDeposit?: FloatFilter<"Contract"> | number
    installmentType?: StringFilter<"Contract"> | string
    installmentCount?: IntFilter<"Contract"> | number
    extraAnnual?: IntFilter<"Contract"> | number
    annualPaymentValue?: FloatFilter<"Contract"> | number
    downPayment?: FloatFilter<"Contract"> | number
    paymentType?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
  }

  export type ContractCreateWithoutUnitInput = {
    id?: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateWithoutUnitInput = {
    id?: string
    customerId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractCreateOrConnectWithoutUnitInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput>
  }

  export type ContractCreateManyUnitInputEnvelope = {
    data: ContractCreateManyUnitInput | ContractCreateManyUnitInput[]
  }

  export type InstallmentCreateWithoutUnitInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InstallmentUncheckedCreateWithoutUnitInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InstallmentCreateOrConnectWithoutUnitInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput>
  }

  export type InstallmentCreateManyUnitInputEnvelope = {
    data: InstallmentCreateManyUnitInput | InstallmentCreateManyUnitInput[]
  }

  export type VoucherCreateWithoutUnitInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    description: string
    payer?: string | null
    beneficiary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    safe: SafeCreateNestedOneWithoutVouchersInput
  }

  export type VoucherUncheckedCreateWithoutUnitInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    safeId: string
    description: string
    payer?: string | null
    beneficiary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherCreateOrConnectWithoutUnitInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput>
  }

  export type VoucherCreateManyUnitInputEnvelope = {
    data: VoucherCreateManyUnitInput | VoucherCreateManyUnitInput[]
  }

  export type UnitPartnerCreateWithoutUnitInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partner: PartnerCreateNestedOneWithoutUnitPartnersInput
  }

  export type UnitPartnerUncheckedCreateWithoutUnitInput = {
    id?: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerCreateOrConnectWithoutUnitInput = {
    where: UnitPartnerWhereUniqueInput
    create: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput>
  }

  export type UnitPartnerCreateManyUnitInputEnvelope = {
    data: UnitPartnerCreateManyUnitInput | UnitPartnerCreateManyUnitInput[]
  }

  export type ContractUpsertWithWhereUniqueWithoutUnitInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutUnitInput, ContractUncheckedUpdateWithoutUnitInput>
    create: XOR<ContractCreateWithoutUnitInput, ContractUncheckedCreateWithoutUnitInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutUnitInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutUnitInput, ContractUncheckedUpdateWithoutUnitInput>
  }

  export type ContractUpdateManyWithWhereWithoutUnitInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutUnitInput>
  }

  export type InstallmentUpsertWithWhereUniqueWithoutUnitInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutUnitInput, InstallmentUncheckedUpdateWithoutUnitInput>
    create: XOR<InstallmentCreateWithoutUnitInput, InstallmentUncheckedCreateWithoutUnitInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutUnitInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutUnitInput, InstallmentUncheckedUpdateWithoutUnitInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutUnitInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutUnitInput>
  }

  export type InstallmentScalarWhereInput = {
    AND?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    OR?: InstallmentScalarWhereInput[]
    NOT?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    id?: StringFilter<"Installment"> | string
    unitId?: StringFilter<"Installment"> | string
    amount?: FloatFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    notes?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
  }

  export type VoucherUpsertWithWhereUniqueWithoutUnitInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutUnitInput, VoucherUncheckedUpdateWithoutUnitInput>
    create: XOR<VoucherCreateWithoutUnitInput, VoucherUncheckedCreateWithoutUnitInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutUnitInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutUnitInput, VoucherUncheckedUpdateWithoutUnitInput>
  }

  export type VoucherUpdateManyWithWhereWithoutUnitInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutUnitInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: StringFilter<"Voucher"> | string
    type?: StringFilter<"Voucher"> | string
    date?: DateTimeFilter<"Voucher"> | Date | string
    amount?: FloatFilter<"Voucher"> | number
    safeId?: StringFilter<"Voucher"> | string
    description?: StringFilter<"Voucher"> | string
    payer?: StringNullableFilter<"Voucher"> | string | null
    beneficiary?: StringNullableFilter<"Voucher"> | string | null
    linkedRef?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
  }

  export type UnitPartnerUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitPartnerWhereUniqueInput
    update: XOR<UnitPartnerUpdateWithoutUnitInput, UnitPartnerUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitPartnerCreateWithoutUnitInput, UnitPartnerUncheckedCreateWithoutUnitInput>
  }

  export type UnitPartnerUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitPartnerWhereUniqueInput
    data: XOR<UnitPartnerUpdateWithoutUnitInput, UnitPartnerUncheckedUpdateWithoutUnitInput>
  }

  export type UnitPartnerUpdateManyWithWhereWithoutUnitInput = {
    where: UnitPartnerScalarWhereInput
    data: XOR<UnitPartnerUpdateManyMutationInput, UnitPartnerUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitPartnerScalarWhereInput = {
    AND?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
    OR?: UnitPartnerScalarWhereInput[]
    NOT?: UnitPartnerScalarWhereInput | UnitPartnerScalarWhereInput[]
    id?: StringFilter<"UnitPartner"> | string
    unitId?: StringFilter<"UnitPartner"> | string
    partnerId?: StringFilter<"UnitPartner"> | string
    percentage?: FloatFilter<"UnitPartner"> | number
    createdAt?: DateTimeFilter<"UnitPartner"> | Date | string
    updatedAt?: DateTimeFilter<"UnitPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UnitPartner"> | Date | string | null
  }

  export type UnitPartnerCreateWithoutPartnerInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutUnitPartnersInput
  }

  export type UnitPartnerUncheckedCreateWithoutPartnerInput = {
    id?: string
    unitId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerCreateOrConnectWithoutPartnerInput = {
    where: UnitPartnerWhereUniqueInput
    create: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type UnitPartnerCreateManyPartnerInputEnvelope = {
    data: UnitPartnerCreateManyPartnerInput | UnitPartnerCreateManyPartnerInput[]
  }

  export type PartnerDebtCreateWithoutPartnerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerDebtUncheckedCreateWithoutPartnerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerDebtCreateOrConnectWithoutPartnerInput = {
    where: PartnerDebtWhereUniqueInput
    create: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerDebtCreateManyPartnerInputEnvelope = {
    data: PartnerDebtCreateManyPartnerInput | PartnerDebtCreateManyPartnerInput[]
  }

  export type PartnerGroupPartnerCreateWithoutPartnerInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partnerGroup: PartnerGroupCreateNestedOneWithoutPartnersInput
  }

  export type PartnerGroupPartnerUncheckedCreateWithoutPartnerInput = {
    id?: string
    partnerGroupId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerCreateOrConnectWithoutPartnerInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    create: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerGroupPartnerCreateManyPartnerInputEnvelope = {
    data: PartnerGroupPartnerCreateManyPartnerInput | PartnerGroupPartnerCreateManyPartnerInput[]
  }

  export type UnitPartnerUpsertWithWhereUniqueWithoutPartnerInput = {
    where: UnitPartnerWhereUniqueInput
    update: XOR<UnitPartnerUpdateWithoutPartnerInput, UnitPartnerUncheckedUpdateWithoutPartnerInput>
    create: XOR<UnitPartnerCreateWithoutPartnerInput, UnitPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type UnitPartnerUpdateWithWhereUniqueWithoutPartnerInput = {
    where: UnitPartnerWhereUniqueInput
    data: XOR<UnitPartnerUpdateWithoutPartnerInput, UnitPartnerUncheckedUpdateWithoutPartnerInput>
  }

  export type UnitPartnerUpdateManyWithWhereWithoutPartnerInput = {
    where: UnitPartnerScalarWhereInput
    data: XOR<UnitPartnerUpdateManyMutationInput, UnitPartnerUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerDebtUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerDebtWhereUniqueInput
    update: XOR<PartnerDebtUpdateWithoutPartnerInput, PartnerDebtUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerDebtCreateWithoutPartnerInput, PartnerDebtUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerDebtUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerDebtWhereUniqueInput
    data: XOR<PartnerDebtUpdateWithoutPartnerInput, PartnerDebtUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerDebtUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerDebtScalarWhereInput
    data: XOR<PartnerDebtUpdateManyMutationInput, PartnerDebtUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerDebtScalarWhereInput = {
    AND?: PartnerDebtScalarWhereInput | PartnerDebtScalarWhereInput[]
    OR?: PartnerDebtScalarWhereInput[]
    NOT?: PartnerDebtScalarWhereInput | PartnerDebtScalarWhereInput[]
    id?: StringFilter<"PartnerDebt"> | string
    partnerId?: StringFilter<"PartnerDebt"> | string
    amount?: FloatFilter<"PartnerDebt"> | number
    dueDate?: DateTimeFilter<"PartnerDebt"> | Date | string
    status?: StringFilter<"PartnerDebt"> | string
    notes?: StringNullableFilter<"PartnerDebt"> | string | null
    createdAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDebt"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerDebt"> | Date | string | null
  }

  export type PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    update: XOR<PartnerGroupPartnerUpdateWithoutPartnerInput, PartnerGroupPartnerUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerGroupPartnerCreateWithoutPartnerInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    data: XOR<PartnerGroupPartnerUpdateWithoutPartnerInput, PartnerGroupPartnerUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerGroupPartnerScalarWhereInput
    data: XOR<PartnerGroupPartnerUpdateManyMutationInput, PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerGroupPartnerScalarWhereInput = {
    AND?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
    OR?: PartnerGroupPartnerScalarWhereInput[]
    NOT?: PartnerGroupPartnerScalarWhereInput | PartnerGroupPartnerScalarWhereInput[]
    id?: StringFilter<"PartnerGroupPartner"> | string
    partnerGroupId?: StringFilter<"PartnerGroupPartner"> | string
    partnerId?: StringFilter<"PartnerGroupPartner"> | string
    percentage?: FloatFilter<"PartnerGroupPartner"> | number
    createdAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerGroupPartner"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PartnerGroupPartner"> | Date | string | null
  }

  export type UnitCreateWithoutUnitPartnersInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractCreateNestedManyWithoutUnitInput
    installments?: InstallmentCreateNestedManyWithoutUnitInput
    vouchers?: VoucherCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnitPartnersInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutUnitInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutUnitInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnitPartnersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnitPartnersInput, UnitUncheckedCreateWithoutUnitPartnersInput>
  }

  export type PartnerCreateWithoutUnitPartnersInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partnerDebts?: PartnerDebtCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutUnitPartnersInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partnerDebts?: PartnerDebtUncheckedCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutUnitPartnersInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutUnitPartnersInput, PartnerUncheckedCreateWithoutUnitPartnersInput>
  }

  export type UnitUpsertWithoutUnitPartnersInput = {
    update: XOR<UnitUpdateWithoutUnitPartnersInput, UnitUncheckedUpdateWithoutUnitPartnersInput>
    create: XOR<UnitCreateWithoutUnitPartnersInput, UnitUncheckedCreateWithoutUnitPartnersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnitPartnersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnitPartnersInput, UnitUncheckedUpdateWithoutUnitPartnersInput>
  }

  export type UnitUpdateWithoutUnitPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnitPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUncheckedUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PartnerUpsertWithoutUnitPartnersInput = {
    update: XOR<PartnerUpdateWithoutUnitPartnersInput, PartnerUncheckedUpdateWithoutUnitPartnersInput>
    create: XOR<PartnerCreateWithoutUnitPartnersInput, PartnerUncheckedCreateWithoutUnitPartnersInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutUnitPartnersInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutUnitPartnersInput, PartnerUncheckedUpdateWithoutUnitPartnersInput>
  }

  export type PartnerUpdateWithoutUnitPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partnerDebts?: PartnerDebtUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutUnitPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partnerDebts?: PartnerDebtUncheckedUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UnitCreateWithoutContractsInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installments?: InstallmentCreateNestedManyWithoutUnitInput
    vouchers?: VoucherCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutContractsInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutUnitInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutContractsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutContractsInput, UnitUncheckedCreateWithoutContractsInput>
  }

  export type CustomerCreateWithoutContractsInput = {
    id?: string
    name: string
    phone?: string | null
    nationalId?: string | null
    address?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    phone?: string | null
    nationalId?: string | null
    address?: string | null
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerCreateOrConnectWithoutContractsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutContractsInput, CustomerUncheckedCreateWithoutContractsInput>
  }

  export type UnitUpsertWithoutContractsInput = {
    update: XOR<UnitUpdateWithoutContractsInput, UnitUncheckedUpdateWithoutContractsInput>
    create: XOR<UnitCreateWithoutContractsInput, UnitUncheckedCreateWithoutContractsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutContractsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutContractsInput, UnitUncheckedUpdateWithoutContractsInput>
  }

  export type UnitUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installments?: InstallmentUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CustomerUpsertWithoutContractsInput = {
    update: XOR<CustomerUpdateWithoutContractsInput, CustomerUncheckedUpdateWithoutContractsInput>
    create: XOR<CustomerCreateWithoutContractsInput, CustomerUncheckedCreateWithoutContractsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutContractsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutContractsInput, CustomerUncheckedUpdateWithoutContractsInput>
  }

  export type CustomerUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitCreateWithoutInstallmentsInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractCreateNestedManyWithoutUnitInput
    vouchers?: VoucherCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutUnitInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutInstallmentsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutInstallmentsInput, UnitUncheckedCreateWithoutInstallmentsInput>
  }

  export type UnitUpsertWithoutInstallmentsInput = {
    update: XOR<UnitUpdateWithoutInstallmentsInput, UnitUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<UnitCreateWithoutInstallmentsInput, UnitUncheckedCreateWithoutInstallmentsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutInstallmentsInput, UnitUncheckedUpdateWithoutInstallmentsInput>
  }

  export type UnitUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUncheckedUpdateManyWithoutUnitNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PartnerCreateWithoutPartnerDebtsInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutPartnerDebtsInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutPartnerInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutPartnerDebtsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutPartnerDebtsInput, PartnerUncheckedCreateWithoutPartnerDebtsInput>
  }

  export type PartnerUpsertWithoutPartnerDebtsInput = {
    update: XOR<PartnerUpdateWithoutPartnerDebtsInput, PartnerUncheckedUpdateWithoutPartnerDebtsInput>
    create: XOR<PartnerCreateWithoutPartnerDebtsInput, PartnerUncheckedCreateWithoutPartnerDebtsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutPartnerDebtsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutPartnerDebtsInput, PartnerUncheckedUpdateWithoutPartnerDebtsInput>
  }

  export type PartnerUpdateWithoutPartnerDebtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutPartnerDebtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutPartnerNestedInput
    partnerGroupPartners?: PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type VoucherCreateWithoutSafeInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    description: string
    payer?: string | null
    beneficiary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unit?: UnitCreateNestedOneWithoutVouchersInput
  }

  export type VoucherUncheckedCreateWithoutSafeInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    description: string
    payer?: string | null
    beneficiary?: string | null
    linkedRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherCreateOrConnectWithoutSafeInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput>
  }

  export type VoucherCreateManySafeInputEnvelope = {
    data: VoucherCreateManySafeInput | VoucherCreateManySafeInput[]
  }

  export type TransferCreateWithoutFromSafeInput = {
    id?: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    toSafe: SafeCreateNestedOneWithoutTransfersToInput
  }

  export type TransferUncheckedCreateWithoutFromSafeInput = {
    id?: string
    toSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutFromSafeInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput>
  }

  export type TransferCreateManyFromSafeInputEnvelope = {
    data: TransferCreateManyFromSafeInput | TransferCreateManyFromSafeInput[]
  }

  export type TransferCreateWithoutToSafeInput = {
    id?: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fromSafe: SafeCreateNestedOneWithoutTransfersFromInput
  }

  export type TransferUncheckedCreateWithoutToSafeInput = {
    id?: string
    fromSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutToSafeInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput>
  }

  export type TransferCreateManyToSafeInputEnvelope = {
    data: TransferCreateManyToSafeInput | TransferCreateManyToSafeInput[]
  }

  export type VoucherUpsertWithWhereUniqueWithoutSafeInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutSafeInput, VoucherUncheckedUpdateWithoutSafeInput>
    create: XOR<VoucherCreateWithoutSafeInput, VoucherUncheckedCreateWithoutSafeInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutSafeInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutSafeInput, VoucherUncheckedUpdateWithoutSafeInput>
  }

  export type VoucherUpdateManyWithWhereWithoutSafeInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutSafeInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutFromSafeInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromSafeInput, TransferUncheckedUpdateWithoutFromSafeInput>
    create: XOR<TransferCreateWithoutFromSafeInput, TransferUncheckedCreateWithoutFromSafeInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromSafeInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromSafeInput, TransferUncheckedUpdateWithoutFromSafeInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromSafeInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromSafeInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    fromSafeId?: StringFilter<"Transfer"> | string
    toSafeId?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    description?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
  }

  export type TransferUpsertWithWhereUniqueWithoutToSafeInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToSafeInput, TransferUncheckedUpdateWithoutToSafeInput>
    create: XOR<TransferCreateWithoutToSafeInput, TransferUncheckedCreateWithoutToSafeInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToSafeInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToSafeInput, TransferUncheckedUpdateWithoutToSafeInput>
  }

  export type TransferUpdateManyWithWhereWithoutToSafeInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToSafeInput>
  }

  export type SafeCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherCreateNestedManyWithoutSafeInput
    transfersTo?: TransferCreateNestedManyWithoutToSafeInput
  }

  export type SafeUncheckedCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherUncheckedCreateNestedManyWithoutSafeInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToSafeInput
  }

  export type SafeCreateOrConnectWithoutTransfersFromInput = {
    where: SafeWhereUniqueInput
    create: XOR<SafeCreateWithoutTransfersFromInput, SafeUncheckedCreateWithoutTransfersFromInput>
  }

  export type SafeCreateWithoutTransfersToInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherCreateNestedManyWithoutSafeInput
    transfersFrom?: TransferCreateNestedManyWithoutFromSafeInput
  }

  export type SafeUncheckedCreateWithoutTransfersToInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vouchers?: VoucherUncheckedCreateNestedManyWithoutSafeInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromSafeInput
  }

  export type SafeCreateOrConnectWithoutTransfersToInput = {
    where: SafeWhereUniqueInput
    create: XOR<SafeCreateWithoutTransfersToInput, SafeUncheckedCreateWithoutTransfersToInput>
  }

  export type SafeUpsertWithoutTransfersFromInput = {
    update: XOR<SafeUpdateWithoutTransfersFromInput, SafeUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<SafeCreateWithoutTransfersFromInput, SafeUncheckedCreateWithoutTransfersFromInput>
    where?: SafeWhereInput
  }

  export type SafeUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: SafeWhereInput
    data: XOR<SafeUpdateWithoutTransfersFromInput, SafeUncheckedUpdateWithoutTransfersFromInput>
  }

  export type SafeUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUpdateManyWithoutSafeNestedInput
    transfersTo?: TransferUpdateManyWithoutToSafeNestedInput
  }

  export type SafeUncheckedUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUncheckedUpdateManyWithoutSafeNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToSafeNestedInput
  }

  export type SafeUpsertWithoutTransfersToInput = {
    update: XOR<SafeUpdateWithoutTransfersToInput, SafeUncheckedUpdateWithoutTransfersToInput>
    create: XOR<SafeCreateWithoutTransfersToInput, SafeUncheckedCreateWithoutTransfersToInput>
    where?: SafeWhereInput
  }

  export type SafeUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: SafeWhereInput
    data: XOR<SafeUpdateWithoutTransfersToInput, SafeUncheckedUpdateWithoutTransfersToInput>
  }

  export type SafeUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUpdateManyWithoutSafeNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromSafeNestedInput
  }

  export type SafeUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vouchers?: VoucherUncheckedUpdateManyWithoutSafeNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromSafeNestedInput
  }

  export type SafeCreateWithoutVouchersInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transfersFrom?: TransferCreateNestedManyWithoutFromSafeInput
    transfersTo?: TransferCreateNestedManyWithoutToSafeInput
  }

  export type SafeUncheckedCreateWithoutVouchersInput = {
    id?: string
    name: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromSafeInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToSafeInput
  }

  export type SafeCreateOrConnectWithoutVouchersInput = {
    where: SafeWhereUniqueInput
    create: XOR<SafeCreateWithoutVouchersInput, SafeUncheckedCreateWithoutVouchersInput>
  }

  export type UnitCreateWithoutVouchersInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractCreateNestedManyWithoutUnitInput
    installments?: InstallmentCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutVouchersInput = {
    id?: string
    code: string
    name?: string | null
    unitType?: string
    area?: string | null
    floor?: string | null
    building?: string | null
    totalPrice?: number
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutUnitInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutUnitInput
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutVouchersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutVouchersInput, UnitUncheckedCreateWithoutVouchersInput>
  }

  export type SafeUpsertWithoutVouchersInput = {
    update: XOR<SafeUpdateWithoutVouchersInput, SafeUncheckedUpdateWithoutVouchersInput>
    create: XOR<SafeCreateWithoutVouchersInput, SafeUncheckedCreateWithoutVouchersInput>
    where?: SafeWhereInput
  }

  export type SafeUpdateToOneWithWhereWithoutVouchersInput = {
    where?: SafeWhereInput
    data: XOR<SafeUpdateWithoutVouchersInput, SafeUncheckedUpdateWithoutVouchersInput>
  }

  export type SafeUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transfersFrom?: TransferUpdateManyWithoutFromSafeNestedInput
    transfersTo?: TransferUpdateManyWithoutToSafeNestedInput
  }

  export type SafeUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromSafeNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToSafeNestedInput
  }

  export type UnitUpsertWithoutVouchersInput = {
    update: XOR<UnitUpdateWithoutVouchersInput, UnitUncheckedUpdateWithoutVouchersInput>
    create: XOR<UnitCreateWithoutVouchersInput, UnitUncheckedCreateWithoutVouchersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutVouchersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutVouchersInput, UnitUncheckedUpdateWithoutVouchersInput>
  }

  export type UnitUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitType?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contracts?: ContractUncheckedUpdateManyWithoutUnitNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutUnitNestedInput
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type BrokerDueCreateWithoutBrokerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerDueUncheckedCreateWithoutBrokerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerDueCreateOrConnectWithoutBrokerInput = {
    where: BrokerDueWhereUniqueInput
    create: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput>
  }

  export type BrokerDueCreateManyBrokerInputEnvelope = {
    data: BrokerDueCreateManyBrokerInput | BrokerDueCreateManyBrokerInput[]
  }

  export type BrokerDueUpsertWithWhereUniqueWithoutBrokerInput = {
    where: BrokerDueWhereUniqueInput
    update: XOR<BrokerDueUpdateWithoutBrokerInput, BrokerDueUncheckedUpdateWithoutBrokerInput>
    create: XOR<BrokerDueCreateWithoutBrokerInput, BrokerDueUncheckedCreateWithoutBrokerInput>
  }

  export type BrokerDueUpdateWithWhereUniqueWithoutBrokerInput = {
    where: BrokerDueWhereUniqueInput
    data: XOR<BrokerDueUpdateWithoutBrokerInput, BrokerDueUncheckedUpdateWithoutBrokerInput>
  }

  export type BrokerDueUpdateManyWithWhereWithoutBrokerInput = {
    where: BrokerDueScalarWhereInput
    data: XOR<BrokerDueUpdateManyMutationInput, BrokerDueUncheckedUpdateManyWithoutBrokerInput>
  }

  export type BrokerDueScalarWhereInput = {
    AND?: BrokerDueScalarWhereInput | BrokerDueScalarWhereInput[]
    OR?: BrokerDueScalarWhereInput[]
    NOT?: BrokerDueScalarWhereInput | BrokerDueScalarWhereInput[]
    id?: StringFilter<"BrokerDue"> | string
    brokerId?: StringFilter<"BrokerDue"> | string
    amount?: FloatFilter<"BrokerDue"> | number
    dueDate?: DateTimeFilter<"BrokerDue"> | Date | string
    status?: StringFilter<"BrokerDue"> | string
    notes?: StringNullableFilter<"BrokerDue"> | string | null
    createdAt?: DateTimeFilter<"BrokerDue"> | Date | string
    updatedAt?: DateTimeFilter<"BrokerDue"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BrokerDue"> | Date | string | null
  }

  export type BrokerCreateWithoutBrokerDuesInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerUncheckedCreateWithoutBrokerDuesInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerCreateOrConnectWithoutBrokerDuesInput = {
    where: BrokerWhereUniqueInput
    create: XOR<BrokerCreateWithoutBrokerDuesInput, BrokerUncheckedCreateWithoutBrokerDuesInput>
  }

  export type BrokerUpsertWithoutBrokerDuesInput = {
    update: XOR<BrokerUpdateWithoutBrokerDuesInput, BrokerUncheckedUpdateWithoutBrokerDuesInput>
    create: XOR<BrokerCreateWithoutBrokerDuesInput, BrokerUncheckedCreateWithoutBrokerDuesInput>
    where?: BrokerWhereInput
  }

  export type BrokerUpdateToOneWithWhereWithoutBrokerDuesInput = {
    where?: BrokerWhereInput
    data: XOR<BrokerUpdateWithoutBrokerDuesInput, BrokerUncheckedUpdateWithoutBrokerDuesInput>
  }

  export type BrokerUpdateWithoutBrokerDuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerUncheckedUpdateWithoutBrokerDuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerCreateWithoutPartnerGroupInput = {
    id?: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    partner: PartnerCreateNestedOneWithoutPartnerGroupPartnersInput
  }

  export type PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput = {
    id?: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerCreateOrConnectWithoutPartnerGroupInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    create: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput>
  }

  export type PartnerGroupPartnerCreateManyPartnerGroupInputEnvelope = {
    data: PartnerGroupPartnerCreateManyPartnerGroupInput | PartnerGroupPartnerCreateManyPartnerGroupInput[]
  }

  export type PartnerGroupPartnerUpsertWithWhereUniqueWithoutPartnerGroupInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    update: XOR<PartnerGroupPartnerUpdateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedUpdateWithoutPartnerGroupInput>
    create: XOR<PartnerGroupPartnerCreateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedCreateWithoutPartnerGroupInput>
  }

  export type PartnerGroupPartnerUpdateWithWhereUniqueWithoutPartnerGroupInput = {
    where: PartnerGroupPartnerWhereUniqueInput
    data: XOR<PartnerGroupPartnerUpdateWithoutPartnerGroupInput, PartnerGroupPartnerUncheckedUpdateWithoutPartnerGroupInput>
  }

  export type PartnerGroupPartnerUpdateManyWithWhereWithoutPartnerGroupInput = {
    where: PartnerGroupPartnerScalarWhereInput
    data: XOR<PartnerGroupPartnerUpdateManyMutationInput, PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerGroupInput>
  }

  export type PartnerGroupCreateWithoutPartnersInput = {
    id?: string
    name: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupUncheckedCreateWithoutPartnersInput = {
    id?: string
    name: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupCreateOrConnectWithoutPartnersInput = {
    where: PartnerGroupWhereUniqueInput
    create: XOR<PartnerGroupCreateWithoutPartnersInput, PartnerGroupUncheckedCreateWithoutPartnersInput>
  }

  export type PartnerCreateWithoutPartnerGroupPartnersInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerCreateNestedManyWithoutPartnerInput
    partnerDebts?: PartnerDebtCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutPartnerGroupPartnersInput = {
    id?: string
    name: string
    phone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    unitPartners?: UnitPartnerUncheckedCreateNestedManyWithoutPartnerInput
    partnerDebts?: PartnerDebtUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutPartnerGroupPartnersInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutPartnerGroupPartnersInput, PartnerUncheckedCreateWithoutPartnerGroupPartnersInput>
  }

  export type PartnerGroupUpsertWithoutPartnersInput = {
    update: XOR<PartnerGroupUpdateWithoutPartnersInput, PartnerGroupUncheckedUpdateWithoutPartnersInput>
    create: XOR<PartnerGroupCreateWithoutPartnersInput, PartnerGroupUncheckedCreateWithoutPartnersInput>
    where?: PartnerGroupWhereInput
  }

  export type PartnerGroupUpdateToOneWithWhereWithoutPartnersInput = {
    where?: PartnerGroupWhereInput
    data: XOR<PartnerGroupUpdateWithoutPartnersInput, PartnerGroupUncheckedUpdateWithoutPartnersInput>
  }

  export type PartnerGroupUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupUncheckedUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerUpsertWithoutPartnerGroupPartnersInput = {
    update: XOR<PartnerUpdateWithoutPartnerGroupPartnersInput, PartnerUncheckedUpdateWithoutPartnerGroupPartnersInput>
    create: XOR<PartnerCreateWithoutPartnerGroupPartnersInput, PartnerUncheckedCreateWithoutPartnerGroupPartnersInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutPartnerGroupPartnersInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutPartnerGroupPartnersInput, PartnerUncheckedUpdateWithoutPartnerGroupPartnersInput>
  }

  export type PartnerUpdateWithoutPartnerGroupPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUpdateManyWithoutPartnerNestedInput
    partnerDebts?: PartnerDebtUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutPartnerGroupPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitPartners?: UnitPartnerUncheckedUpdateManyWithoutPartnerNestedInput
    partnerDebts?: PartnerDebtUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type ContractCreateManyCustomerInput = {
    id?: string
    unitId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateManyUnitInput = {
    id?: string
    customerId: string
    start: Date | string
    totalPrice: number
    discountAmount?: number
    brokerName?: string | null
    brokerPercent?: number
    brokerAmount?: number
    commissionSafeId?: string | null
    downPaymentSafeId?: string | null
    maintenanceDeposit?: number
    installmentType?: string
    installmentCount?: number
    extraAnnual?: number
    annualPaymentValue?: number
    downPayment?: number
    paymentType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InstallmentCreateManyUnitInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherCreateManyUnitInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    safeId: string
    description: string
    payer?: string | null
    beneficiary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerCreateManyUnitInput = {
    id?: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContractUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    brokerName?: NullableStringFieldUpdateOperationsInput | string | null
    brokerPercent?: FloatFieldUpdateOperationsInput | number
    brokerAmount?: FloatFieldUpdateOperationsInput | number
    commissionSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    downPaymentSafeId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceDeposit?: FloatFieldUpdateOperationsInput | number
    installmentType?: StringFieldUpdateOperationsInput | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    extraAnnual?: IntFieldUpdateOperationsInput | number
    annualPaymentValue?: FloatFieldUpdateOperationsInput | number
    downPayment?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    safe?: SafeUpdateOneRequiredWithoutVouchersNestedInput
  }

  export type VoucherUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    safeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    safeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partner?: PartnerUpdateOneRequiredWithoutUnitPartnersNestedInput
  }

  export type UnitPartnerUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerCreateManyPartnerInput = {
    id?: string
    unitId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerDebtCreateManyPartnerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerCreateManyPartnerInput = {
    id?: string
    partnerGroupId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UnitPartnerUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutUnitPartnersNestedInput
  }

  export type UnitPartnerUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitPartnerUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerDebtUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partnerGroup?: PartnerGroupUpdateOneRequiredWithoutPartnersNestedInput
  }

  export type PartnerGroupPartnerUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerGroupId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerGroupId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateManySafeInput = {
    id?: string
    type: string
    date: Date | string
    amount: number
    description: string
    payer?: string | null
    beneficiary?: string | null
    linkedRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferCreateManyFromSafeInput = {
    id?: string
    toSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransferCreateManyToSafeInput = {
    id?: string
    fromSafeId: string
    amount: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VoucherUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneWithoutVouchersNestedInput
  }

  export type VoucherUncheckedUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    linkedRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateManyWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payer?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiary?: NullableStringFieldUpdateOperationsInput | string | null
    linkedRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutFromSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toSafe?: SafeUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    toSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutFromSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    toSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutToSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromSafe?: SafeUpdateOneRequiredWithoutTransfersFromNestedInput
  }

  export type TransferUncheckedUpdateWithoutToSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutToSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromSafeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueCreateManyBrokerInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BrokerDueUpdateWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueUncheckedUpdateWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrokerDueUncheckedUpdateManyWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerCreateManyPartnerGroupInput = {
    id?: string
    partnerId: string
    percentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PartnerGroupPartnerUpdateWithoutPartnerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    partner?: PartnerUpdateOneRequiredWithoutPartnerGroupPartnersNestedInput
  }

  export type PartnerGroupPartnerUncheckedUpdateWithoutPartnerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartnerGroupPartnerUncheckedUpdateManyWithoutPartnerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}